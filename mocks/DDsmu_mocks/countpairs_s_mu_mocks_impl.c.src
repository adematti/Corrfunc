// # -*- mode: c -*-
/* File: countpairs_s_mu_mocks_impl.c.src */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/
*/

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#include "defs.h"
#include "utils.h"
#include "cpu_features.h"
#include "progressbar.h"

#if defined(_OPENMP)
#include <omp.h>
#endif

#include "gridlink_mocks_impl_DOUBLE.h"
#include "gridlink_utils_DOUBLE.h"

#include "countpairs_s_mu_mocks_impl_DOUBLE.h"
#include "countpairs_s_mu_mocks_kernels_DOUBLE.c"

#ifdef GPU
#include "countpairs_s_mu_mocks_gpu.h"
#endif

int interrupt_status_DDsmu_mocks_DOUBLE=EXIT_SUCCESS;

void interrupt_handler_countpairs_s_mu_mocks_DOUBLE(int signo)
{
    fprintf(stderr,"Received signal = `%s' (signo = %d). Aborting \n",strsignal(signo), signo);
    interrupt_status_DDsmu_mocks_DOUBLE = EXIT_FAILURE;
}


countpairs_mocks_func_ptr_DOUBLE countpairs_s_mu_mocks_driver_DOUBLE(const struct config_options *options)
{

    static countpairs_mocks_func_ptr_DOUBLE function = NULL;
    static isa old_isa = (isa) -1;
    if(old_isa == options->instruction_set) {
        return function;
    }

    /* Array of function pointers */
    countpairs_mocks_func_ptr_DOUBLE allfunctions[] = {
        countpairs_s_mu_mocks_fallback_DOUBLE,
#ifdef __SSE4_2__
        countpairs_s_mu_mocks_sse_intrinsics_DOUBLE,
#endif
#ifdef __AVX__
        countpairs_s_mu_mocks_avx_intrinsics_DOUBLE,
#endif
#ifdef __AVX512F__
        countpairs_s_mu_mocks_avx512_intrinsics_DOUBLE,
#endif
    };

    const int num_functions = sizeof(allfunctions)/sizeof(void *);
    const int fallback_index = 0;
#if defined(__AVX512F__) || defined(__AVX__) || defined(__SSE4_2__)
    const int highest_isa = get_max_usable_isa();
#endif
    int curr_index = 0;

    /* Is the SSE function supported at runtime and enabled at compile-time?*/
    int sse_index = curr_index;
#ifdef __SSE4_2__
    curr_index++;
    if(highest_isa >= SSE42) sse_index = curr_index;
#endif

    /* Now check if AVX is supported by the CPU */
    int avx_index = curr_index;
#ifdef __AVX__
    curr_index++;
    if(highest_isa >= AVX) avx_index = curr_index;
#endif

    /* Check for AVX512F support */
    int avx512_index = curr_index;
#ifdef __AVX512F__
    curr_index++;
    if(highest_isa >= AVX512F) avx512_index = curr_index;
#endif

    if( curr_index != num_functions-1) {
      fprintf(stderr,"ERROR: Bug in code (current index = %d *should equal* num_functions-1 = %d-1)\n",
              curr_index, num_functions);
      return NULL;
    }

    int function_dispatch = num_functions-1;  //Set default to fastest available
    /* Check that cpu supports feature */
    if(options->instruction_set >= 0) {
        switch(options->instruction_set) {
        case(AVX512F):function_dispatch=avx512_index;break;
        case(AVX2):
        case(AVX):function_dispatch=avx_index;break;
        case(SSE42):function_dispatch=sse_index;break;
        default:function_dispatch=fallback_index;break;
        }
    }
    if(function_dispatch >= num_functions) {
      fprintf(stderr,"In %s> ERROR: Could not resolve the correct function.\n Function index = %d must lie between [0, %d)\n",
              __FUNCTION__, function_dispatch, num_functions);
      return NULL;
    }
    function = allfunctions[function_dispatch];
    old_isa = options->instruction_set;

    if(options->verbose){
        // Must be ordered low to high, since higher ISA may be aliased to lower ones
#ifdef GPU
        if (options->use_gpu) {
            fprintf(stderr,"Using GPU kernel\n");
        } else
#endif
        if(function_dispatch == fallback_index){
            fprintf(stderr,"Using fallback kernel\n");
        } else if(function_dispatch == sse_index){
            fprintf(stderr,"Using SSE kernel\n");
        } else if(function_dispatch == avx_index){
            fprintf(stderr,"Using AVX kernel\n");
        } else if(function_dispatch == avx512_index){
            fprintf(stderr,"Using AVX512 kernel\n");
        } else {
            fprintf(stderr,"Unknown kernel!\n");
            return NULL;
        }
    }

    return function;
}


int countpairs_mocks_s_mu_DOUBLE(const int64_t ND1, DOUBLE *X1, DOUBLE *Y1, DOUBLE *Z1,
                                 const int64_t ND2, DOUBLE *X2, DOUBLE *Y2, DOUBLE *Z2,
                                 const int numthreads,
                                 const int autocorr,
                                 binarray *bins,
                                 const double max_mu,
                                 const int nmu_bins,
                                 results_countpairs_mocks_s_mu *results,
                                 struct config_options *options, struct extra_options *extra)
{

    if(options->float_type != sizeof(DOUBLE)) {
        fprintf(stderr,"ERROR: In %s> Can only handle arrays of size=%zu. Got an array of size = %zu\n",
                __FUNCTION__, sizeof(DOUBLE), options->float_type);
        return EXIT_FAILURE;
    }

    bool use_gpu = (bool)options->use_gpu;


    /***********************
     *initializing the  bins
     ************************/
    double *supp = bins->edges;
    int nsbin = bins->nedges;
    double smin=bins->edges[0], smax=bins->edges[bins->nedges-1];
    if( ! (smin >= 0.0 && smax > 0.0 && smin < smax && nsbin > 0)) {
        fprintf(stderr,"Error: Could not setup with s bins correctly. (smin = %lf, smax = %lf, with nbins = %d). Expected non-zero smin/smax with smax > smin and nbins >=1 \n",
                smin, smax, nsbin);
        return EXIT_FAILURE;
    }
    detect_bin_type(bins, &(options->bin_type), options->verbose);

    if(max_mu <= 0.) {
        fprintf(stderr,"Error: max_mu (max. value for the cosine of the angle with line of sight) must be greater than 0 and at most 1).\n"
                "The passed value is max_mu = %lf. Please change it to be > 0 and <= 1\n", max_mu);
        return EXIT_FAILURE;
    }

    if(nmu_bins < 1 ) {
        fprintf(stderr,"Error: Number of mu bins = %d must be at least 1\n", nmu_bins);
        return EXIT_FAILURE;
    }

    DOUBLE supp_sqr[nsbin];
    const int totnbins = (nmu_bins+1)*(nsbin+1);
    for(int i=0; i < nsbin;i++) {
        supp_sqr[i] = supp[i]*supp[i];
    }
    const DOUBLE mu_max = (DOUBLE) max_mu;

    results->nsbin = nsbin;
    results->nmu_bins = nmu_bins;
    results->mu_max = max_mu;//NOTE max_mu which is double and not mu_max (which might be float)
    results->mu_min = -max_mu;
    results->npairs = my_calloc(sizeof(*(results->npairs)), totnbins);
    results->supp = my_malloc(sizeof(*(results->supp)), nsbin);
    results->savg = my_calloc(sizeof(*(results->savg)), totnbins);
    results->weightavg = my_calloc(sizeof(double), totnbins);
    if(results->npairs == NULL || results->supp == NULL || results->savg == NULL || results->weightavg == NULL) {
        free_results_mocks_s_mu(results);
        return EXIT_FAILURE;
    }

    for(int i=0;i<nsbin;i++) results->supp[i] = supp[i];

    //Check inputs
    if(ND1 == 0 || (autocorr == 0 && ND2 == 0)) {
        return EXIT_SUCCESS;
    }

    // If no extra options were passed, create dummy options
    // This allows us to pass arguments like "extra->weights0" below;
    // they'll just be NULLs, which is the correct behavior
    struct extra_options dummy_extra;
    if(extra == NULL){
      weight_method_t dummy_method = NONE;
      dummy_extra = get_extra_options(dummy_method);
      extra = &dummy_extra;
    }

    int need_weightavg = extra->weight_method != NONE;

    options->sort_on_z = 1;
    struct timeval t0;
    if(options->c_api_timer) {
        gettimeofday(&t0, NULL);
    }
    if(options->fast_divide_and_NR_steps >= MAX_FAST_DIVIDE_NR_STEPS) {
        fprintf(stderr, ANSI_COLOR_MAGENTA"Warning: The number of requested Newton-Raphson steps = %u is larger than max. allowed steps = %u."
                " Switching to a standard divide"ANSI_COLOR_RESET"\n",
                options->fast_divide_and_NR_steps, MAX_FAST_DIVIDE_NR_STEPS);
        options->fast_divide_and_NR_steps = 0;
    }

#if defined(_OPENMP)
    omp_set_num_threads(numthreads);
#else
    (void) numthreads;
#endif

    if(options->max_cells_per_dim == 0) {
        fprintf(stderr,"Warning: Max. cells per dimension is set to 0 - resetting to `NLATMAX' = %d\n", NLATMAX);
        options->max_cells_per_dim = NLATMAX;
    }
    for(int i=0;i<3;i++) {
        if(options->bin_refine_factors[i] < 1) {
            fprintf(stderr,"Warning: bin refine factor along axis = %d *must* be >=1. Instead found bin refine factor =%d\n",
                    i, options->bin_refine_factors[i]);
            reset_bin_refine_factors(options);
            break;/* all factors have been reset -> no point continuing with the loop */
        }
    }

    /* setup interrupt handler -> mostly useful during the python execution.
       Let's Ctrl-C abort the extension  */
    SETUP_INTERRUPT_HANDLERS(interrupt_handler_countpairs_s_mu_mocks_DOUBLE);

    DOUBLE xmin, xmax, ymin, ymax, zmin, zmax;
    xmin = ymin = zmin = MAX_POSITIVE_FLOAT;
    xmax = ymax = zmax = -MAX_POSITIVE_FLOAT;
    get_max_min_DOUBLE(ND1, X1, Y1, Z1, &xmin, &ymin, &zmin, &xmax, &ymax, &zmax);

    if(autocorr==0) {
        get_max_min_DOUBLE(ND2, X2, Y2, Z2, &xmin, &ymin, &zmin, &xmax, &ymax, &zmax);
    }

    const DOUBLE xdiff = xmax-xmin;
    const DOUBLE ydiff = ymax-ymin;
    const DOUBLE zdiff = zmax-zmin;
    if(get_bin_refine_scheme(options) == BINNING_DFL) {
        if(smax < 0.05*xdiff) {
            options->bin_refine_factors[0] = 1;
      }
        if(smax < 0.05*ydiff) {
            options->bin_refine_factors[1] = 1;
        }
        if(smax < 0.05*zdiff) {
            options->bin_refine_factors[2] = 1;
        }
    }

    /*---Create 3-D lattice--------------------------------------*/
    int nmesh_x=0,nmesh_y=0,nmesh_z=0;
    cellarray_mocks_DOUBLE *lattice1 = gridlink_mocks_DOUBLE(ND1, X1, Y1, Z1, &(extra->weights0),
                                                             xmin, xmax, ymin, ymax, zmin, zmax,
                                                             smax, smax, smax,
                                                             options->bin_refine_factors[0],
                                                             options->bin_refine_factors[1],
                                                             options->bin_refine_factors[2],
                                                             &nmesh_x, &nmesh_y, &nmesh_z,
                                                             options);
    if(lattice1 == NULL) {
        return EXIT_FAILURE;
    }

    /* If there too few cells (BOOST_CELL_THRESH is ~10), and the number of cells can be increased, then boost bin refine factor by ~1*/
    const double avg_np = ((double)ND1)/(nmesh_x*nmesh_y*nmesh_z);
    const int max_nmesh = fmax(nmesh_x, fmax(nmesh_y, nmesh_z));
    if((max_nmesh <= BOOST_CELL_THRESH || avg_np >= BOOST_NUMPART_THRESH)
       && max_nmesh < options->max_cells_per_dim) {
        if(options->verbose) {
            fprintf(stderr,"%s> gridlink seems inefficient. nmesh = (%d, %d, %d); avg_np = %.3g. ", __FUNCTION__, nmesh_x, nmesh_y, nmesh_z, avg_np);
        }
        if(get_bin_refine_scheme(options) == BINNING_DFL) {
            if(options->verbose) {
                fprintf(stderr,"Boosting bin refine factor - should lead to better performance\n");
            }
            // Only boost the first two dimensions.  Prevents excessive refinement.
            for(int i=0;i<2;i++) {
                options->bin_refine_factors[i] += BOOST_BIN_REF;
            }

            free_cellarray_mocks_DOUBLE(lattice1, nmesh_x * (int64_t) nmesh_y * nmesh_z);
            lattice1 = gridlink_mocks_DOUBLE(ND1, X1, Y1, Z1, &(extra->weights0),
                                             xmin, xmax, ymin, ymax, zmin, zmax,
                                             smax, smax, smax,
                                             options->bin_refine_factors[0],
                                             options->bin_refine_factors[1],
                                             options->bin_refine_factors[2],
                                             &nmesh_x, &nmesh_y, &nmesh_z,
                                             options);
            if(lattice1 == NULL) {
                return EXIT_FAILURE;
            }
        } else {
            if(options->verbose) {
                fprintf(stderr,"Boosting bin refine factor could have helped. However, since custom bin refine factors "
                        "= (%d, %d, %d) are being used - continuing with inefficient mesh\n", options->bin_refine_factors[0],
                        options->bin_refine_factors[1], options->bin_refine_factors[2]);
            }
        }
    }

    cellarray_mocks_DOUBLE *lattice2 = NULL;
    if(autocorr==0) {
        int ngrid2_x=0,ngrid2_y=0,ngrid2_z=0;
        lattice2 = gridlink_mocks_DOUBLE(ND2, X2, Y2, Z2, &(extra->weights1),
                                         xmin, xmax,
                                         ymin, ymax,
                                         zmin, zmax,
                                         smax, smax, smax,
                                         options->bin_refine_factors[0],
                                         options->bin_refine_factors[1],
                                         options->bin_refine_factors[2],
                                         &ngrid2_x, &ngrid2_y, &ngrid2_z, options);
        if(lattice2 == NULL) {
            return EXIT_FAILURE;
        }
        if( ! (nmesh_x == ngrid2_x && nmesh_y == ngrid2_y && nmesh_z == ngrid2_z) ) {
            fprintf(stderr,"Error: The two sets of 3-D lattices do not have identical bins. First has dims (%d, %d, %d) while second has (%d, %d, %d)\n",
                    nmesh_x, nmesh_y, nmesh_z, ngrid2_x, ngrid2_y, ngrid2_z);
            return EXIT_FAILURE;
        }
    } else {
        lattice2 = lattice1;
    }

    const int64_t totncells = (int64_t) nmesh_x * (int64_t) nmesh_y * (int64_t) nmesh_z;

    int64_t num_cell_pairs = 0;
    struct cell_pair_DOUBLE *all_cell_pairs = generate_cell_pairs_mocks_DOUBLE(lattice1, lattice2, totncells,
                                                                               &num_cell_pairs,
                                                                               options->bin_refine_factors[0],
                                                                               options->bin_refine_factors[1],
                                                                               options->bin_refine_factors[2],
                                                                               nmesh_x, nmesh_y, nmesh_z,
                                                                               smax,
                                                                               options->enable_min_sep_opt,
                                                                               autocorr);
    if(all_cell_pairs == NULL) {
        free_cellarray_mocks_DOUBLE(lattice1, totncells);
        if(autocorr == 0) {
            free_cellarray_mocks_DOUBLE(lattice2, totncells);
        }
        return EXIT_FAILURE;
    }

    uint64_t *npairs = (uint64_t *) my_calloc(sizeof(uint64_t), totnbins);
    DOUBLE *savg = NULL;
    if(options->need_avg_sep){
        savg = (DOUBLE *) my_calloc(sizeof(DOUBLE), totnbins);
    }
    DOUBLE *weightavg = NULL;
    if(need_weightavg) {
        weightavg = (DOUBLE *) my_calloc(sizeof(DOUBLE), totnbins);
    }
    /*---Gridlink-variables----------------*/
#if defined(_OPENMP)
    uint64_t **all_npairs = (uint64_t **) matrix_calloc(sizeof(uint64_t), numthreads, totnbins);
    DOUBLE **all_savg = NULL;
    if(options->need_avg_sep){
        all_savg = (DOUBLE **) matrix_calloc(sizeof(DOUBLE),numthreads,totnbins);
    }
    DOUBLE **all_weightavg = NULL;
    if(need_weightavg) {
        all_weightavg = (DOUBLE **) matrix_calloc(sizeof(DOUBLE),numthreads,totnbins);
    }
#endif //USE_OMP

    /* runtime dispatch - get the function pointer */
    countpairs_mocks_func_ptr_DOUBLE countpairs_s_mu_mocks_function_DOUBLE = countpairs_s_mu_mocks_driver_DOUBLE(options);
    if(countpairs_s_mu_mocks_function_DOUBLE == NULL) {
        return EXIT_FAILURE;
    }

    int interrupted=0,numdone=0, abort_status=EXIT_SUCCESS;
    if(options->verbose) {
        init_my_progressbar(num_cell_pairs, &interrupted);
    }

#ifdef GPU
    //declare GPU arrays here - there's no real penalty if use_gpu is false, they never get allocated
    DOUBLE *gpu_X1, *gpu_Y1, *gpu_Z1;
    DOUBLE *gpu_X2, *gpu_Y2, *gpu_Z2;
    DOUBLE *gpu_W1, *gpu_W2;

    DOUBLE *gpu_min_dx, *gpu_min_dy; //min_dz not needed for GPU kernel
    DOUBLE *gpu_supp_sqr;

    //with multi-GPU mode, declare outputs within OPENMP parallel block
    // - gpu_npairs, gpu_savg, gpu_weightavg

    int *gpu_same_cell;
    int64_t *gpu_icell0, *gpu_icell1;
    int *gpu_np0, *gpu_np1;
    int *gpu_start_idx0, *gpu_start_idx1;

    uint8_t nw1 = (extra->weights0).num_weights;
    uint8_t nw2 = (extra->weights1).num_weights;

    //define max threads and max blocks here
    const int max_threads = 400000000; //400M
    const int max_blocks = (max_threads+THREADS_PER_BLOCK-1) / THREADS_PER_BLOCK; //max num blocks

    //allocate global arrays here outside of OPENMP parallel block
    //outputs and block LUTs will be allocated inside OPENMP block
    if (use_gpu) {
        gpu_allocate_mocks_DOUBLE(&gpu_X1, &gpu_Y1, &gpu_Z1, ND1);
        gpu_allocate_mocks_DOUBLE(&gpu_X2, &gpu_Y2, &gpu_Z2, ND2);
        gpu_allocate_mins_DOUBLE(&gpu_min_dx, &gpu_min_dy, num_cell_pairs);
        gpu_allocate_cell_luts(&gpu_same_cell, &gpu_icell0, &gpu_icell1, num_cell_pairs);
        gpu_allocate_lattice_luts(&gpu_np0, &gpu_start_idx0, totncells);
        gpu_allocate_lattice_luts(&gpu_np1, &gpu_start_idx1, totncells);
        if (nw1 > 0) gpu_allocate_weights_DOUBLE(&gpu_W1, ND1, nw1);
        if (nw2 > 0) gpu_allocate_weights_DOUBLE(&gpu_W2, ND2, nw2);
        gpu_allocate_supp_sqr_DOUBLE(&gpu_supp_sqr, nsbin);

        //copy data to GPU
        for (int i = 0; i < nsbin; i++) gpu_supp_sqr[i] = supp_sqr[i];

        //int64_t tcount = 0; //thread count
        int64_t icell1, icell2;
        //int64_t maxc = 0, minc = 0;
        //int64_t this_count = 0;
        for(int64_t icellpair=0;icellpair<num_cell_pairs;icellpair++) {
                struct cell_pair_DOUBLE *this_cell_pair = &all_cell_pairs[icellpair];
                gpu_min_dx[icellpair] = this_cell_pair->min_dx;
                gpu_min_dy[icellpair] = this_cell_pair->min_dy;
                gpu_same_cell[icellpair] = (int)this_cell_pair->same_cell;
                icell1 = this_cell_pair->cellindex1;
                icell2 = this_cell_pair->cellindex2;
                gpu_icell0[icellpair] = icell1;
                gpu_icell1[icellpair] = icell2;
                //thread count is total number of inner loop iterations
                //this_count = (&lattice1[icell1])->nelements * (&lattice2[icell2])->nelements;
                //tcount += this_count;
                //if (this_count > maxc) maxc= this_count;
                //if (minc == 0 || this_count < minc) minc = this_count;
        }

        //loop over lattices and populate LUTs
        int pcount1 = 0, pcount2 = 0;
        int64_t i1 = 0, i2 = 0;
        for (int64_t icell = 0; icell<totncells; icell++) {
                gpu_np0[icell] = (&lattice1[icell])->nelements;
                gpu_np1[icell] = (&lattice2[icell])->nelements;
                gpu_start_idx0[icell] = pcount1;
                gpu_start_idx1[icell] = pcount2;
                pcount1 += (&lattice1[icell])->nelements;
                pcount2 += (&lattice2[icell])->nelements;
                const cellarray_mocks_DOUBLE *first = &lattice1[icell];
                const cellarray_mocks_DOUBLE *second = &lattice2[icell];
                //loop over elements in first, second cells
                for (int i_first = 0; i_first < first->nelements; i_first++) {
                       //loop over weights if nw1 > 0 and copy them
                        for (int i_w = 0; i_w < nw1; i_w++) {
                            gpu_W1[i1*nw1+i_w] = first->weights.weights[i_w][i_first];
                        }
                        gpu_X1[i1] = first->x[i_first];
                        gpu_Y1[i1] = first->y[i_first];
                        gpu_Z1[i1++] = first->z[i_first];
                }
                for (int i_second = 0; i_second < second->nelements; i_second++) {
                        //loop over weights if nw1 > 1 and copy them
                        for (int i_w = 0; i_w < nw2; i_w++) {
                            gpu_W2[i2*nw2+i_w] = second->weights.weights[i_w][i_second];
                        }
                        gpu_X2[i2] = second->x[i_second];
                        gpu_Y2[i2] = second->y[i_second];
                        gpu_Z2[i2++] = second->z[i_second];
                }
        }
    }
#endif

#if defined(_OPENMP)
#pragma omp parallel shared(numdone, abort_status, interrupt_status_DDsmu_mocks_DOUBLE)
    {
        const int tid = omp_get_thread_num();
        uint64_t *this_npairs = all_npairs[tid];
        DOUBLE *this_savg = NULL;
        if(options->need_avg_sep) {
            this_savg = all_savg[tid];
        }
        DOUBLE *this_weightavg = NULL;
        if(need_weightavg) {
            this_weightavg = all_weightavg[tid];
        }
#else
        uint64_t *this_npairs = npairs;
        DOUBLE *this_savg = savg;
        DOUBLE *this_weightavg = weightavg;
#endif//USE_OMP

        DOUBLE *tmp_savg = NULL, *tmp_weightavg = NULL;
        if(options->need_avg_sep) tmp_savg = (DOUBLE *) malloc(sizeof(DOUBLE)*totnbins);
        if(need_weightavg) tmp_weightavg = (DOUBLE *) malloc(sizeof(DOUBLE)*totnbins);

#ifdef GPU
#if defined(_OPENMP)
        //check n gpu so as to not crash if more threads than GPU are specified
        int ngpu;
        cudaGetDeviceCount(&ngpu);
        int gputhreads = numthreads;
        if (gputhreads > ngpu) gputhreads = ngpu;
        int64_t cellpair_start = tid*num_cell_pairs/gputhreads;
        int64_t cellpair_end = (tid+1)*num_cell_pairs/gputhreads;
        if (use_gpu && tid < ngpu) {
                //set CUDA device to this thread id
                //should never have more threads than GPUs
                cudaSetDevice(tid);
        }
#else
        int64_t cellpair_start = 0;
        int64_t cellpair_end = num_cell_pairs;
#endif //USE_OMP

        //declare and populate output arrays and block LUTs for GPU here, within OPENMP parallel block
        DOUBLE *gpu_savg;
        DOUBLE *gpu_weightavg;
        int *gpu_npairs;
        int *gpu_cellpair_lut, *gpu_cellthread_lut;

        if (use_gpu) {
            //Only execute for thread ids < ngpu
            if (tid < ngpu) {
                //gpu_print_cuda_error();
                gpu_allocate_outputs_DOUBLE(&gpu_savg, &gpu_npairs, totnbins);
                for(int j=0;j<totnbins;j++) {
                    gpu_savg[j] = 0.;
                    gpu_npairs[j] = 0;
                }
                if (need_weightavg) {
                    gpu_allocate_weight_output_DOUBLE(&gpu_weightavg, totnbins);
                    for(int j=0;j<totnbins;j++) gpu_weightavg[j] = 0.;
                }
                gpu_allocate_block_luts(&gpu_cellpair_lut, &gpu_cellthread_lut, max_blocks);

                //if using multi GPU + OPENMP, call GPU version of countpairs_s_mu_mocks_gpu_DOUBLE here
                const int status = countpairs_s_mu_mocks_gpu_DOUBLE(ND1, gpu_X1, gpu_Y1, gpu_Z1, gpu_W1, nw1,
                                                                         ND2, gpu_X2, gpu_Y2, gpu_Z2, gpu_W2, nw2,
                                                                         gpu_same_cell,
                                                                         gpu_icell0, gpu_icell1, num_cell_pairs,
                                                                         cellpair_start, cellpair_end,
                                                                         gpu_np0, gpu_np1, gpu_start_idx0, gpu_start_idx1,
                                                                         smax, smin, nsbin, nmu_bins, gpu_supp_sqr, mu_max,
                                                                         gpu_min_dx, gpu_min_dy,
                                                                         gpu_savg, gpu_npairs,
                                                                         gpu_weightavg, extra->weight_method, options->selection,
                                                                         options->bin_type, options->los_type, autocorr,
                                                                         gpu_cellpair_lut, gpu_cellthread_lut, options->verbose);
                abort_status |= status;
            }
        } else {
#endif //GPU

#if defined(_OPENMP)
#pragma omp for schedule(dynamic)
#endif
            /*---Loop-over-all-cell-pairs--------------------*/
            for(int64_t icellpair=0;icellpair<num_cell_pairs;icellpair++) {
#if defined(_OPENMP)
#pragma omp flush (abort_status, interrupt_status_DDsmu_mocks_DOUBLE)
#endif
                if(abort_status == EXIT_SUCCESS && interrupt_status_DDsmu_mocks_DOUBLE == EXIT_SUCCESS) {
                    //omp cancel was introduced in omp 4.0 - so this is my way of checking if loop needs to be cancelled
                    /* If the verbose option is not enabled, avoid outputting anything unnecessary*/
                    if(options->verbose) {
#if defined(_OPENMP)
                        if (omp_get_thread_num() == 0)
#endif
                            my_progressbar(numdone,&interrupted);


#if defined(_OPENMP)
#pragma omp atomic
#endif
                        numdone++;
                    }

                    struct cell_pair_DOUBLE *this_cell_pair = &all_cell_pairs[icellpair];

                    const int64_t icell = this_cell_pair->cellindex1;
                    const int64_t icell2 = this_cell_pair->cellindex2;
                    const cellarray_mocks_DOUBLE *first = &lattice1[icell];
                    const cellarray_mocks_DOUBLE *second = &lattice2[icell2];

                    if(options->need_avg_sep) {
                        for(int j=0;j<totnbins;j++) tmp_savg[j] = 0.;
                    }
                    if(need_weightavg) {
                        for(int j=0;j<totnbins;j++) tmp_weightavg[j] = 0.;
                    }

                    const int status = countpairs_s_mu_mocks_function_DOUBLE(first->nelements, first->x, first->y, first->z, &(first->weights),
                                                                         second->nelements, second->x, second->y, second->z, &(second->weights),
                                                                         this_cell_pair->same_cell,
                                                                         options->fast_divide_and_NR_steps,
                                                                         smax, smin, nsbin, nmu_bins, supp_sqr, mu_max,
                                                                         this_cell_pair->min_dx, this_cell_pair->min_dy, this_cell_pair->min_dz,
                                                                         this_cell_pair->closest_x1, this_cell_pair->closest_y1, this_cell_pair->closest_z1,
                                                                         tmp_savg, this_npairs, tmp_weightavg,
                                                                         extra->weight_method, extra->pair_weight, options->selection, options->bin_type, options->los_type, autocorr);

                    /* This actually causes a race condition under OpenMP - but mostly
                       I care that an error occurred - rather than the exact value of
                       the error status */
                    abort_status |= status;

                    if(options->need_avg_sep) {
                        for(int j=0;j<totnbins;j++) this_savg[j] += tmp_savg[j];
                    }
                    if(need_weightavg) {
                        for(int j=0;j<totnbins;j++) this_weightavg[j] += tmp_weightavg[j];
                    }

                }//abort-status
            }//icellpair loop over num_cell_pairs
#ifdef GPU
        //end if-else block in GPU mode
        }
#endif

    free(tmp_savg);
    free(tmp_weightavg);
#ifdef GPU
    //Free memory and copy outputs back to CPU
    //Handle outputs and block LUTs here
    //This will sum up all multi-GPU results (use +=)
    //Check thread id to make sure it is < ngpu
    if (use_gpu && tid < ngpu) {
        //Copy outputs back to CPU
        for (int j = 0; j < totnbins; j++) {
            npairs[j] += (uint64_t)gpu_npairs[j];
        }
        if(options->need_avg_sep) {
            for (int j = 0; j < totnbins; j++) {
                savg[j] += gpu_savg[j];
            }
        }
        gpu_free_outputs_DOUBLE(gpu_savg, gpu_npairs);

        if (need_weightavg) {
            for (int j = 0; j < totnbins; j++) {
                weightavg[j] += gpu_weightavg[j];
            }
            gpu_free_weight_output_DOUBLE(gpu_weightavg);
        }
        gpu_free_block_luts(gpu_cellpair_lut, gpu_cellthread_lut);
    }
#endif

#if defined(_OPENMP)
    }//close the omp parallel region
#endif//USE_OMP
#ifdef GPU
    //Free memory and copy outputs back to CPU
    if (use_gpu) {
        gpu_free_mocks_DOUBLE(gpu_X1, gpu_Y1, gpu_Z1);
        gpu_free_mocks_DOUBLE(gpu_X2, gpu_Y2, gpu_Z2);
        gpu_free_mins_DOUBLE(gpu_min_dx, gpu_min_dy);
        gpu_free_cell_luts(gpu_same_cell, gpu_icell0, gpu_icell1);
        gpu_free_lattice_luts(gpu_np0, gpu_start_idx0);
        gpu_free_lattice_luts(gpu_np1, gpu_start_idx1);
        gpu_free_supp_sqr_DOUBLE(gpu_supp_sqr);
    }
#endif
    free(all_cell_pairs);

    if(options->copy_particles == 0) {
        int64_t *original_index = lattice1[0].original_index;
        int status = reorder_particles_back_into_original_order_DOUBLE(ND1, original_index, X1, Y1, Z1, &(extra->weights0));
        if(status != EXIT_SUCCESS) {
            return status;
        }
        if(autocorr == 0) {
            original_index = lattice2[0].original_index;
            status = reorder_particles_back_into_original_order_DOUBLE(ND2, original_index, X2, Y2, Z2, &(extra->weights1));
            if(status != EXIT_SUCCESS) {
                return status;
            }
        }
    }

    free_cellarray_mocks_DOUBLE(lattice1,totncells);
    if(autocorr == 0) {
        free_cellarray_mocks_DOUBLE(lattice2,totncells);
    }

    if(abort_status != EXIT_SUCCESS || interrupt_status_DDsmu_mocks_DOUBLE != EXIT_SUCCESS) {
        /* Cleanup memory here if aborting */
#if defined(_OPENMP)
        matrix_free((void **) all_npairs, numthreads);
        if(options->need_avg_sep) {
            matrix_free((void **) all_savg, numthreads);
        }
        if(need_weightavg) {
            matrix_free((void **) all_weightavg, numthreads);
        }
#endif
        return EXIT_FAILURE;
    }

    if(options->verbose) {
        finish_myprogressbar(&interrupted);
    }

#if defined(_OPENMP)
    for(int i=0;i<numthreads;i++) {
        for(int j=0;j<totnbins;j++) {
            npairs[j] += all_npairs[i][j];
            if(options->need_avg_sep) {
                savg[j] += all_savg[i][j];
            }
            if(need_weightavg) {
                weightavg[j] += all_weightavg[i][j];
            }
        }
    }
    matrix_free((void **) all_npairs, numthreads);
    if(options->need_avg_sep) {
        matrix_free((void **) all_savg, numthreads);
    }
    if(need_weightavg) {
        matrix_free((void **) all_weightavg, numthreads);
    }
#endif //USE_OMP

    if(autocorr == 1) {
        /* Is the min. requested separation 0.0 ?*/
        /* The comparison is '<=' rather than '==' only to silence
           the compiler  */
        int with_auto_pairs = (supp[0] <= 0.0);
        if (options->selection.selection_type & RP_SELECTION) {
            with_auto_pairs &= (options->selection.rpmin_sqr <= 0.);
        }
        if(with_auto_pairs) {
            /* Then, add all the self-pairs. This ensures that
               a cross-correlation with two identical datasets
               produces the same result as the auto-correlation  */
            npairs[nmu_bins+nmu_bins/2+1] += ND1; //npairs[1] contains the first valid bin.

            // Increasing npairs affects savg and weightavg.
            // We don't need to add anything to savg; all the self-pairs have 0 separation!
            // The self-pairs have non-zero weight, though.  So, fix that here.
            if(need_weightavg){
                // Keep in mind this is an autocorrelation (i.e. only one particle set to consider)
                pair_struct_DOUBLE pair;
                set_pair_struct_DOUBLE(&pair, (weight_struct_DOUBLE *) &(extra->weights0), (weight_struct_DOUBLE *) &(extra->weights0), &(extra->pair_weight));
                weight_func_t_DOUBLE weight_func = get_weight_func_by_method_DOUBLE(extra->weight_method);
                for(int64_t j = 0; j < ND1; j++){
                    for(int w = 0; w < pair.num_weights; w++){
                        pair.weights0[w].d = ((DOUBLE *) extra->weights0.weights[w])[j];
                        pair.weights1[w].d = ((DOUBLE *) extra->weights0.weights[w])[j];
                    }
                    weightavg[nmu_bins+nmu_bins/2+1] += weight_func(&pair);
                }
            }
        }
    }

    for(int i=0;i<totnbins;i++) {
        if(npairs[i] > 0) {
            if(options->need_avg_sep) {
                savg[i] /= need_weightavg ? weightavg[i] : (DOUBLE) npairs[i];
            }
            if(need_weightavg) {
                weightavg[i] /= (DOUBLE) npairs[i];
            }
        }
    }

    for(int i=0;i<nsbin;i++) {
        for(int j=0;j<nmu_bins;j++) {
            const int index = i*(nmu_bins+1) + j;
            if( index >= totnbins ) {
                fprintf(stderr, "ERROR: In %s> index = %d must be in range [0, %d)\n", __FUNCTION__, index, totnbins);
                free_results_mocks_s_mu(results);
                return EXIT_FAILURE;
            }
            results->npairs[index] = npairs[index];
            if(options->need_avg_sep) {
                results->savg[index] = savg[index];
            }
            if(need_weightavg) {
                results->weightavg[index] = weightavg[index];
            }
        }
    }
    free(npairs); free(savg); free(weightavg);

    /* reset interrupt handlers to default */
    RESET_INTERRUPT_HANDLERS();
    reset_bin_refine_factors(options);

    if(options->c_api_timer) {
        struct timeval t1;
        gettimeofday(&t1, NULL);
        options->c_api_time = ADD_DIFF_TIME(t0, t1);
    }

    return EXIT_SUCCESS;
}
