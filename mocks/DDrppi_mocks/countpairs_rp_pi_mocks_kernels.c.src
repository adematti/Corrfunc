// # -*- mode: c -*-
/* File: countpairs_rp_pi_mocks_kernels.c */
/*
  This file is a part of the Corrfunc package
  Copyright (C) 2015-- Manodeep Sinha (manodeep@gmail.com)
  License: MIT LICENSE. See LICENSE file under the top-level
  directory at https://github.com/manodeep/Corrfunc/

  Changed in v2.3: Particles are now sorted in Cartesian 'z' positions.
                   Previously particles were sorted in comoving distance, 'd'

*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include <inttypes.h>

#include "defs.h"
#include "function_precision.h"
#include "utils.h"

#include "weight_functions_DOUBLE.h"


#ifdef __AVX512F__
#include "avx512_calls.h"

static inline int countpairs_rp_pi_mocks_avx512_intrinsics_DOUBLE(const int64_t N0, DOUBLE *x0, DOUBLE *y0, DOUBLE *z0,
                                                                  const weight_struct_DOUBLE *weights0,
                                                                  const int64_t N1, DOUBLE *x1, DOUBLE *y1, DOUBLE *z1,
                                                                  const weight_struct_DOUBLE *weights1,
                                                                  const int same_cell,
                                                                  const unsigned int fast_divide_and_NR_steps,
                                                                  const DOUBLE rpmax, const DOUBLE rpmin, const int nbin, const int npibin,
                                                                  const DOUBLE *rupp_sqr, const DOUBLE pimax,
                                                                  const DOUBLE min_xdiff, const DOUBLE min_ydiff, const DOUBLE min_zdiff,
                                                                  const DOUBLE closest_icell_xpos, const DOUBLE closest_icell_ypos,
                                                                  const DOUBLE closest_icell_zpos,
                                                                  DOUBLE *rpavg,
                                                                  uint64_t *npairs, DOUBLE *weightavg, const weight_method_t weight_method, const pair_weight_struct pair_weight,
                                                                  const bin_type_t bin_type, const los_type_t los_type, const int autocorr)
{
    if(N0 == 0 || N1 == 0) {
        return EXIT_SUCCESS;
    }

    if(npairs == NULL) {
        return EXIT_FAILURE;
    }

    const int32_t need_rpavg = rpavg != NULL;
    const int32_t need_weightavg = weightavg != NULL;
    int32_t need_costheta = need_weightavg;
    const DOUBLE sqr_rpmin=rpmin*rpmin, sqr_rpmax=rpmax*rpmax;
    AVX512_FLOATS m_inv_rpstep = AVX512_SETZERO_FLOAT();
    AVX512_FLOATS m_rpmin_invstep = AVX512_SETZERO_FLOAT();
    if (bin_type == BIN_LIN) {
        const DOUBLE inv_rpstep = (nbin - 1)/(rpmax - rpmin);
        const DOUBLE rpmin_invstep = 1 - rpmin*inv_rpstep; //trick to avoid adding one to (r - rmin)/rstep
        m_inv_rpstep = AVX512_SET_FLOAT(inv_rpstep);
        m_rpmin_invstep = AVX512_SET_FLOAT(rpmin_invstep);
    }

    const DOUBLE sqr_max_sep = sqr_rpmax + pimax*pimax;
    const DOUBLE sqr_pimax = pimax*pimax;

    AVX512_FLOATS m_rupp_sqr[nbin];
    for(int i=0;i<nbin;i++) {
        m_rupp_sqr[i] = AVX512_SET_FLOAT(rupp_sqr[i]);
    }

    const DOUBLE inv_dpi = ((DOUBLE) npibin)/(2*pimax);
    const DOUBLE pimin_invstep = pimax*inv_dpi;

    // A copy whose pointers we can advance
    weight_struct_DOUBLE local_w0 = {.weights={NULL}, .num_weights=0}, local_w1 = {.weights={NULL}, .num_weights=0};
    pair_struct_DOUBLE pair = {.num_weights=0};
    avx512_weight_func_t_DOUBLE avx512_weight_func = NULL;
    if(need_weightavg){
        // Same particle list, new copy of num_weights pointers into that list
        local_w0 = *weights0;
        local_w1 = *weights1;

        set_pair_struct_DOUBLE(&pair, &local_w0, &local_w1, &pair_weight);
        need_costheta = pair_weight.num;
        avx512_weight_func = get_avx512_weight_func_by_method_DOUBLE(weight_method);
    }
    DOUBLE *xhat1 = NULL, *yhat1 = NULL, *zhat1 = NULL;
    if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
        xhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        yhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        zhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        for(int64_t i=0;i<N1;i++) {
            const DOUBLE norm1 = SQRT(x1[i]*x1[i] + y1[i]*y1[i] + z1[i]*z1[i]);
            xhat1[i] = x1[i]/norm1;
            yhat1[i] = y1[i]/norm1;
            zhat1[i] = z1[i]/norm1;
        }
    }

    const DOUBLE *zstart = z1, *zend = z1 + N1;
    const DOUBLE max_all_dz = SQRT(sqr_max_sep - min_xdiff*min_xdiff - min_ydiff*min_ydiff);
    for(int64_t i=0;i<N0;i++) {
        const DOUBLE xpos = *x0++;
        const DOUBLE ypos = *y0++;
        const DOUBLE zpos = *z0++;
        for(int w = 0; w < pair.num_weights; w++){
            // local_w0.weights[w] is a pointer to a float in the particle list of weights,
            // just as x0 is a pointer into the list of x-positions.
            // The advancement of the local_w0.weights[w] pointer should always mirror x0.
            pair.weights0[w].a512 = AVX512_SET_FLOAT(*(local_w0.weights[w])++);
        }
        DOUBLE xhat0 = ZERO, yhat0 = ZERO, zhat0 = ZERO;
        if (need_costheta || los_type == FIRSTPOINT_LOS) {
            const DOUBLE norm0 = SQRT(xpos*xpos + ypos*ypos + zpos*zpos);
            xhat0 = xpos/norm0;
            yhat0 = ypos/norm0;
            zhat0 = zpos/norm0;
        }

        DOUBLE max_dz = max_all_dz;

        /* Now consider if this i'th particle can be a valid pair with ANY of the remaining
           j' particles. The min. difference in the d-positions between this i'th particle and ANY
           of the remaining j'th particles, is the difference between the current j'th particle and
           the current i'th particle (since all remaining j'th particles will have a larger value for
           the z-ordinate and therefore a larger difference to zpos). if this `dsep` does not satisfy
           the distance criteria, then NO remaining j'th particles will. Continue on to the next i'th
           particle
        */
        const DOUBLE this_dz = *z1 - zpos;
        if(this_dz >= max_all_dz) {
            continue;
        }

        if(same_cell == 1) {
            z1++;
        } else {
            const DOUBLE min_dx = min_xdiff > 0 ? min_xdiff + FABS(xpos - closest_icell_xpos):min_xdiff;
            const DOUBLE min_dy = min_ydiff > 0 ? min_ydiff + FABS(ypos - closest_icell_ypos):min_ydiff;
            const DOUBLE min_dz = min_zdiff > 0 ? (this_dz > 0 ? this_dz:min_zdiff + FABS(zpos - closest_icell_zpos)):min_zdiff;
            const DOUBLE sqr_min_sep_this_point = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
            if(sqr_min_sep_this_point >= sqr_max_sep) {
                continue;
            }
            max_dz = SQRT(sqr_max_sep - min_dx*min_dx - min_dy*min_dy);

            const DOUBLE target_z = zpos - max_all_dz;
            while(z1 != zend && *z1 <= target_z) {
                z1++;
            }

        }/* end of same_cell if condition*/

        /* are there any pairs possible with this particle and ANY
           of the j'th particles?
           Since both z0 and z1 are sorted in increasing order,
           the largest value for z1 is stored in last_z1. Therefore,
           the smallest difference between ANY of the remaining i'th particle
           and ANY of the j'th particle is:
           the current particle (i.e., the smallest remaining z-position among the 'i'-th dataset)
           and the last j'th particle. Therefore, if this difference is already too large
           to contain a valid pair, any remaining particle pairs CAN NOT be a valid pair

           --> we can safely terminate the i-loop (i.e., terminate the calculation for this pair of
               cells)
        */
        if(z1 == zend) {
            i = N0;
            break;
        }

        DOUBLE *localz1 = z1;
        const DOUBLE target_z = zpos - max_dz;
        while(localz1 != zend && *localz1 <= target_z) {
            localz1++;
        }

        const int64_t n_off = localz1 - zstart;
        DOUBLE *localx1 = x1 + n_off;
        DOUBLE *localy1 = y1 + n_off;
        for(int w = 0; w < local_w1.num_weights; w++){
            local_w1.weights[w] = weights1->weights[w] + n_off;
        }

        const AVX512_FLOATS m_xpos = AVX512_SET_FLOAT(xpos);
        const AVX512_FLOATS m_ypos = AVX512_SET_FLOAT(ypos);
        const AVX512_FLOATS m_zpos = AVX512_SET_FLOAT(zpos);
        const AVX512_FLOATS m_xhat0 = AVX512_SET_FLOAT(xhat0);
        const AVX512_FLOATS m_yhat0 = AVX512_SET_FLOAT(yhat0);
        const AVX512_FLOATS m_zhat0 = AVX512_SET_FLOAT(zhat0);

        const AVX512_FLOATS m_sqr_pimax = AVX512_SET_FLOAT(sqr_pimax);
        const AVX512_FLOATS m_sqr_rpmax = AVX512_SET_FLOAT(sqr_rpmax);
        const AVX512_FLOATS m_sqr_rpmin = AVX512_SET_FLOAT(sqr_rpmin);
        const AVX512_FLOATS m_sqr_max_sep = AVX512_SET_FLOAT(sqr_max_sep);
        const AVX512_FLOATS m_max_dz = AVX512_SET_FLOAT(max_dz);
        const AVX512_FLOATS m_inv_dpi = AVX512_SET_FLOAT(inv_dpi);
        const AVX512_FLOATS m_inv_dpi_opp = AVX512_SET_FLOAT(-inv_dpi);
        const AVX512_FLOATS m_pimin_invstep = AVX512_SET_FLOAT(pimin_invstep);
        const AVX512_FLOATS m_npibin = AVX512_SET_FLOAT((DOUBLE) npibin);
        const AVX512_FLOATS m_npibin_p1 = AVX512_SET_FLOAT((DOUBLE) npibin + 1);

        for(int64_t j=n_off;j<N1;j+=AVX512_NVEC){
            AVX512_MASK m_mask_left = (N1 - j) >= AVX512_NVEC ? ~0:masks_per_misalignment_value_DOUBLE[N1-j];
            const AVX512_FLOATS m_x2 = AVX512_MASKZ_LOAD_FLOATS_UNALIGNED(m_mask_left, localx1);
            const AVX512_FLOATS m_y2 = AVX512_MASKZ_LOAD_FLOATS_UNALIGNED(m_mask_left, localy1);
            const AVX512_FLOATS m_z2 = AVX512_MASKZ_LOAD_FLOATS_UNALIGNED(m_mask_left, localz1);
            AVX512_FLOATS m_xhat1, m_yhat1, m_zhat1;
            if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
                m_xhat1 = AVX512_LOAD_FLOATS_UNALIGNED(xhat1 + j);
                m_yhat1 = AVX512_LOAD_FLOATS_UNALIGNED(yhat1 + j);
                m_zhat1 = AVX512_LOAD_FLOATS_UNALIGNED(zhat1 + j);
            }
            union int16 union_finalbin;
            union float16 union_mDperp;
            union float16_weights union_mweight;

            union_finalbin.m_ibin = AVX512_SETZERO_INT();
            union_mDperp.m_Dperp = AVX512_SETZERO_FLOAT();

#ifdef COUNT_VECTORIZED
            vectorized_npairs += AVX512_NVEC;
#endif

            localx1 += AVX512_NVEC;
            localy1 += AVX512_NVEC;
            localz1 += AVX512_NVEC;

            for(int w = 0; w < pair.num_weights; w++){
                pair.weights1[w].a512 = AVX512_MASKZ_LOAD_FLOATS_UNALIGNED(m_mask_left, local_w1.weights[w]);
                local_w1.weights[w] += AVX512_NVEC;
            }

            const AVX512_FLOATS m_perpx = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_x2, m_xpos);
            const AVX512_FLOATS m_perpy = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_y2, m_ypos);
            const AVX512_FLOATS m_perpz = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_z2, m_zpos);

            const AVX512_FLOATS m_parx = AVX512_MASKZ_ADD_FLOATS(m_mask_left, m_x2, m_xpos);
            const AVX512_FLOATS m_pary = AVX512_MASKZ_ADD_FLOATS(m_mask_left, m_y2, m_ypos);
            const AVX512_FLOATS m_parz = AVX512_MASKZ_ADD_FLOATS(m_mask_left, m_z2, m_zpos);

            /* Since the particles are sorted on 'z', we can check if any of the dz values >= max_dz */
            const AVX512_MASK m_mask_dz = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_perpz, m_max_dz, _CMP_GE_OQ);
            if(m_mask_dz > 0) {
                /* this means the next chunk of particles can not be within 's' */
                j = N1;/* but do not break out of the loop because this chunk might contain valid pairs */
            }

            AVX512_FLOATS m_sqr_sep = AVX512_FMA_ADD_FLOATS(m_perpx, m_perpx, AVX512_FMA_ADD_FLOATS(m_perpy, m_perpy, AVX512_SQUARE_FLOAT(m_perpz)));//3-d separation

            const AVX512_MASK m_mask_sep = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_sep, m_sqr_max_sep, _CMP_LT_OQ);
            if(m_mask_sep == 0) continue;

            AVX512_FLOATS m_sqr_Dperp, m_sqr_Dperp2, m_pibin, m_pibin2;
            AVX512_MASK m_mask_left1, m_mask_left2;
            if (los_type == MIDPOINT_LOS) {
                const AVX512_FLOATS m_s_dot_l = AVX512_FMA_ADD_FLOATS(m_parz, m_perpz, AVX512_FMA_ADD_FLOATS(m_pary, m_perpy, AVX512_MULTIPLY_FLOATS(m_parx, m_perpx)));
                const AVX512_FLOATS m_sqr_l = AVX512_FMA_ADD_FLOATS(m_parx, m_parx, AVX512_FMA_ADD_FLOATS(m_pary, m_pary, AVX512_SQUARE_FLOAT(m_parz)));
                const AVX512_FLOATS m_sqr_pimax_times_sqr_l = AVX512_MULTIPLY_FLOATS(m_sqr_pimax, m_sqr_l);
                const AVX512_FLOATS m_sqr_s_dot_l = AVX512_SQUARE_FLOAT(m_s_dot_l);
                const AVX512_MASK m_mask_pimax_sep = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_s_dot_l, m_sqr_pimax_times_sqr_l, _CMP_LT_OQ);// is pi < pimax ?
                m_mask_left = AVX512_MASK_BITWISE_AND(m_mask_sep, m_mask_pimax_sep);
                if(m_mask_left == 0) continue;
                AVX512_FLOATS m_sqr_Dpar = AVX512_SETZERO_FLOAT();
                CHECK_AND_FAST_DIVIDE_AVX512(m_sqr_Dpar, m_sqr_s_dot_l, m_sqr_l, m_mask_left, fast_divide_and_NR_steps);
                m_sqr_Dperp = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_sqr_sep, m_sqr_Dpar);
                const AVX512_MASK m_rpmax_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp, m_sqr_rpmax, _CMP_LT_OQ);
                const AVX512_MASK m_rpmin_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp, m_sqr_rpmin, _CMP_GE_OQ);
                m_mask_left = m_mask_left1 = m_mask_left2 = AVX512_MASK_BITWISE_AND(m_mask_pimax_sep, AVX512_MASK_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if(m_mask_left == 0) continue;
                const AVX512_FLOATS m_pi = AVX512_SIGNED_FLOATS(AVX512_MASKZ_SQRT_FLOAT(m_mask_left, m_sqr_Dpar), m_s_dot_l);
                m_pibin = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left, m_pi, m_inv_dpi, m_pimin_invstep);
                if (autocorr == 1) m_pibin2 = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left, m_pi, m_inv_dpi_opp, m_pimin_invstep);
            }
            else {
                const AVX512_FLOATS m_s_dot_l = AVX512_FMA_ADD_FLOATS(m_zhat0, m_perpz, AVX512_FMA_ADD_FLOATS(m_yhat0, m_perpy, AVX512_MULTIPLY_FLOATS(m_xhat0, m_perpx)));
                const AVX512_FLOATS m_sqr_Dpar = AVX512_SQUARE_FLOAT(m_s_dot_l);
                const AVX512_MASK m_mask_pimax_sep = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dpar, m_sqr_pimax, _CMP_LT_OQ);// is pi < pimax ?
                m_sqr_Dperp = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_sqr_sep, m_sqr_Dpar);
                const AVX512_MASK m_rpmax_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp, m_sqr_rpmax, _CMP_LT_OQ);
                const AVX512_MASK m_rpmin_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp, m_sqr_rpmin, _CMP_GE_OQ);
                m_mask_left1 = AVX512_MASK_BITWISE_AND(m_mask_pimax_sep, AVX512_MASK_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if (autocorr == 1) {
                    const AVX512_FLOATS m_s_dot_l2 = AVX512_FMA_ADD_FLOATS(m_zhat1, m_perpz, AVX512_FMA_ADD_FLOATS(m_yhat1, m_perpy, AVX512_MULTIPLY_FLOATS(m_xhat1, m_perpx)));
                    const AVX512_FLOATS m_sqr_Dpar2 = AVX512_SQUARE_FLOAT(m_s_dot_l2);
                    const AVX512_MASK m_mask_pimax_sep2 = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dpar2, m_sqr_pimax, _CMP_LT_OQ);// is pi < pimax ?
                    m_sqr_Dperp2 = AVX512_MASKZ_SUBTRACT_FLOATS(m_mask_left, m_sqr_sep, m_sqr_Dpar2);
                    const AVX512_MASK m_rpmax_mask2 = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp2, m_sqr_rpmax, _CMP_LT_OQ);
                    const AVX512_MASK m_rpmin_mask2 = AVX512_MASK_COMPARE_FLOATS(m_mask_left, m_sqr_Dperp2, m_sqr_rpmin, _CMP_GE_OQ);
                    m_mask_left2 = AVX512_MASK_BITWISE_AND(m_mask_pimax_sep2, AVX512_MASK_BITWISE_AND(m_rpmax_mask2, m_rpmin_mask2));
                    m_mask_left = AVX512_MASK_BITWISE_OR(m_mask_left1, m_mask_left2);
                    if (m_mask_left == 0) continue;
                    m_pibin = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left1, m_s_dot_l, m_inv_dpi, m_pimin_invstep);
                    m_pibin2 = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left2, m_s_dot_l2, m_inv_dpi_opp, m_pimin_invstep);
                }
                else {
                    m_mask_left = m_mask_left1;
                    if (m_mask_left == 0) continue;
                    m_pibin = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left, m_s_dot_l, m_inv_dpi, m_pimin_invstep);
                }
            }

            if(need_costheta) pair.costheta.a512 = AVX512_FMA_ADD_FLOATS(m_zhat0, m_zhat1, AVX512_FMA_ADD_FLOATS(m_yhat0, m_yhat1, AVX512_MULTIPLY_FLOATS(m_xhat0, m_xhat1)));

            if(need_weightavg){
                pair.dx.a512 = m_perpx;
                pair.dy.a512 = m_perpy;
                pair.dz.a512 = m_perpz;

                pair.parx.a512 = m_parx;
                pair.pary.a512 = m_pary;
                pair.parz.a512 = m_parz;

                union_mweight.m_weights = avx512_weight_func(&pair);
            }

            AVX512_MASK m_mask = m_mask_left1;
            if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = AVX512_MASKZ_SQRT_FLOAT(m_mask_left1, m_sqr_Dperp);
            AVX512_FLOATS m_rpbin = AVX512_SETZERO_FLOAT();
            if (bin_type == BIN_LIN) {
                m_rpbin = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left1, union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep);
            }
            else {
              for(int kbin=nbin-1;kbin>=1;kbin--) {
                  const AVX512_MASK m_bin_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left1, m_sqr_Dperp, m_rupp_sqr[kbin-1],_CMP_GE_OQ);
                  m_rpbin = AVX512_BLEND_FLOATS_WITH_MASK(m_bin_mask, m_rpbin, AVX512_SET_FLOAT(kbin));
                  m_mask_left = AVX512_MASK_BITWISE_AND_NOT(m_bin_mask, m_mask_left1);//ANDNOT(X, Y) -> NOT X AND Y
                  if(m_mask_left == 0) break;
               }
            }
            /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
            /*                      const AVX512_FLOATS m_Dpar = AVX512_SQRT_FLOAT(m_sqr_Dpar); */

            m_rpbin = AVX512_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);  // already blended with mask (npibin)
            union_finalbin.m_ibin = AVX512_TRUNCATE_FLOAT_TO_INT(AVX512_MASK_ADD_FLOATS(m_npibin, m_mask, m_rpbin, m_pibin));
            if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = AVX512_MASKZ_MULTIPLY_FLOATS(m_mask, union_mDperp.m_Dperp, union_mweight.m_weights);

#if  __INTEL_COMPILER
#pragma unroll(AVX512_NVEC)
#endif
            for(int jj=0;jj<AVX512_NVEC;jj++) {
                const int ibin = union_finalbin.ibin[jj];
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
            }

            if (autocorr == 1) {
                m_mask = m_mask_left2;
                if (los_type == MIDPOINT_LOS) {
                    union_finalbin.m_ibin = AVX512_TRUNCATE_FLOAT_TO_INT(AVX512_MASK_ADD_FLOATS(m_npibin, m_mask, m_rpbin, m_pibin2));
                }
                else {
                    if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = AVX512_MASKZ_SQRT_FLOAT(m_mask_left2, m_sqr_Dperp2);
                    m_rpbin = AVX512_SETZERO_FLOAT();
                    if (bin_type == BIN_LIN) {
                        m_rpbin = AVX512_MASKZ_FMA_ADD_TRUNCATE_FLOATS(m_mask_left2, union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep);
                    }
                    else {
                        for(int kbin=nbin-1;kbin>=1;kbin--) {
                            const AVX512_MASK m_bin_mask = AVX512_MASK_COMPARE_FLOATS(m_mask_left2, m_sqr_Dperp2, m_rupp_sqr[kbin-1],_CMP_GE_OQ);
                            m_rpbin = AVX512_BLEND_FLOATS_WITH_MASK(m_bin_mask, m_rpbin, AVX512_SET_FLOAT(kbin));
                            m_mask_left2 = AVX512_MASK_BITWISE_AND_NOT(m_bin_mask, m_mask_left2);//ANDNOT(X, Y) -> NOT X AND Y
                            if(m_mask_left2 == 0) break;
                         }
                    }
                    /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
                    m_rpbin = AVX512_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);  // already blended with mask (npibin)
                    union_finalbin.m_ibin = AVX512_TRUNCATE_FLOAT_TO_INT(AVX512_MASK_ADD_FLOATS(m_npibin, m_mask, m_rpbin, m_pibin));
                    if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = AVX512_MASKZ_MULTIPLY_FLOATS(m_mask, union_mDperp.m_Dperp, union_mweight.m_weights);

#if  __INTEL_COMPILER
#pragma unroll(AVX512_NVEC)
#endif
                    for(int jj=0;jj<AVX512_NVEC;jj++) {
                        const int ibin = union_finalbin.ibin[jj];
                        npairs[ibin]++;
                        if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                        if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
                    }
                }
            }
        }//AVX512 j loop
    }//i-loop

    free(xhat1); free(yhat1); free(zhat1);

    return EXIT_SUCCESS;
}
#endif //AVX512F defined

#if defined(__AVX__)
#include "avx_calls.h"

static inline int countpairs_rp_pi_mocks_avx_intrinsics_DOUBLE(const int64_t N0, DOUBLE *x0, DOUBLE *y0, DOUBLE *z0,
                                                               const weight_struct_DOUBLE *weights0,
                                                               const int64_t N1, DOUBLE *x1, DOUBLE *y1, DOUBLE *z1,
                                                               const weight_struct_DOUBLE *weights1,
                                                               const int same_cell,
                                                               const unsigned int fast_divide_and_NR_steps,
                                                               const DOUBLE rpmax, const DOUBLE rpmin, const int nbin, const int npibin,
                                                               const DOUBLE *rupp_sqr, const DOUBLE pimax,
                                                               const DOUBLE min_xdiff, const DOUBLE min_ydiff, const DOUBLE min_zdiff,
                                                               const DOUBLE closest_icell_xpos, const DOUBLE closest_icell_ypos,
                                                               const DOUBLE closest_icell_zpos,
                                                               DOUBLE *rpavg,
                                                               uint64_t *npairs, DOUBLE *weightavg, const weight_method_t weight_method, const pair_weight_struct pair_weight,
                                                               const bin_type_t bin_type, const los_type_t los_type, const int autocorr)
{
    if(N0 == 0 || N1 == 0) {
        return EXIT_SUCCESS;
    }

    if(npairs == NULL) {
        return EXIT_FAILURE;
    }

    const int32_t need_rpavg = rpavg != NULL;
    const int32_t need_weightavg = weightavg != NULL;
    int32_t need_costheta = need_weightavg;
    const DOUBLE sqr_rpmin=rpmin*rpmin, sqr_rpmax=rpmax*rpmax;
    DOUBLE inv_rpstep=0., rpmin_invstep=0.;
    AVX_FLOATS m_inv_rpstep = AVX_SETZERO_FLOAT();
    AVX_FLOATS m_rpmin_invstep = AVX_SETZERO_FLOAT();
    if (bin_type == BIN_LIN) {
        inv_rpstep = (nbin - 1)/(rpmax - rpmin);
        rpmin_invstep = 1 - rpmin*inv_rpstep; //trick to avoid adding one to (r - rmin)/rstep
        m_inv_rpstep = AVX_SET_FLOAT(inv_rpstep);
        m_rpmin_invstep = AVX_SET_FLOAT(rpmin_invstep);
    }

    const DOUBLE sqr_max_sep = sqr_rpmax + pimax*pimax;
    const DOUBLE sqr_pimax = pimax*pimax;

    AVX_FLOATS m_rupp_sqr[nbin];
    AVX_FLOATS m_kbin[nbin];
    for(int i=0;i<nbin;i++) {
        m_rupp_sqr[i] = AVX_SET_FLOAT(rupp_sqr[i]);
        m_kbin[i] = AVX_SET_FLOAT((DOUBLE) i);
    }

    const DOUBLE inv_dpi = ((DOUBLE) npibin)/(2*pimax);
    const DOUBLE pimin_invstep = pimax*inv_dpi;

    // A copy whose pointers we can advance
    weight_struct_DOUBLE local_w0 = {.weights={NULL}, .num_weights=0}, local_w1 = {.weights={NULL}, .num_weights=0};
    pair_struct_DOUBLE pair = {.num_weights=0};
    avx_weight_func_t_DOUBLE avx_weight_func = NULL;
    weight_func_t_DOUBLE fallback_weight_func = NULL;
    if(need_weightavg){
        // Same particle list, new copy of num_weights pointers into that list
        local_w0 = *weights0;
        local_w1 = *weights1;

        set_pair_struct_DOUBLE(&pair, &local_w0, &local_w1, &pair_weight);
        need_costheta = pair_weight.num;
        avx_weight_func = get_avx_weight_func_by_method_DOUBLE(weight_method);
        fallback_weight_func = get_weight_func_by_method_DOUBLE(weight_method);
    }
    DOUBLE *xhat1 = NULL, *yhat1 = NULL, *zhat1 = NULL;
    if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
        xhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        yhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        zhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        for(int64_t i=0;i<N1;i++) {
            const DOUBLE norm1 = SQRT(x1[i]*x1[i] + y1[i]*y1[i] + z1[i]*z1[i]);
            xhat1[i] = x1[i]/norm1;
            yhat1[i] = y1[i]/norm1;
            zhat1[i] = z1[i]/norm1;
        }
    }

    const DOUBLE *zstart = z1, *zend = z1 + N1;
    const DOUBLE max_all_dz = SQRT(sqr_max_sep - min_xdiff*min_xdiff - min_ydiff*min_ydiff);
    for(int64_t i=0;i<N0;i++) {
        const DOUBLE xpos = *x0++;
        const DOUBLE ypos = *y0++;
        const DOUBLE zpos = *z0++;
        for(int w = 0; w < pair.num_weights; w++){
            // local_w0.weights[w] is a pointer to a float in the particle list of weights,
            // just as x0 is a pointer into the list of x-positions.
            // The advancement of the local_w0.weights[w] pointer should always mirror x0.
            pair.weights0[w].a = AVX_SET_FLOAT(*(local_w0.weights[w])++);
        }

        DOUBLE xhat0 = ZERO, yhat0 = ZERO, zhat0 = ZERO;
        if (need_costheta || los_type == FIRSTPOINT_LOS) {
            const DOUBLE norm0 = SQRT(xpos*xpos + ypos*ypos + zpos*zpos);
            xhat0 = xpos/norm0;
            yhat0 = ypos/norm0;
            zhat0 = zpos/norm0;
        }

        DOUBLE max_dz = max_all_dz;

        /* Now consider if this i'th particle can be a valid pair with ANY of the remaining
           j' particles. The min. difference in the d-positions between this i'th particle and ANY
           of the remaining j'th particles, is the difference between the current j'th particle and
           the current i'th particle (since all remaining j'th particles will have a larger value for
           the z-ordinate and therefore a larger difference to zpos). if this `dsep` does not satisfy
           the distance criteria, then NO remaining j'th particles will. Continue on to the next i'th
           particle
        */
        const DOUBLE this_dz = *z1 - zpos;
        if(this_dz >= max_all_dz) {
            continue;
        }

        if(same_cell == 1) {
            z1++;
        } else {
            const DOUBLE min_dx = min_xdiff > 0 ? min_xdiff + FABS(xpos - closest_icell_xpos):min_xdiff;
            const DOUBLE min_dy = min_ydiff > 0 ? min_ydiff + FABS(ypos - closest_icell_ypos):min_ydiff;
            const DOUBLE min_dz = min_zdiff > 0 ? (this_dz > 0 ? this_dz:min_zdiff + FABS(zpos - closest_icell_zpos)):min_zdiff;
            const DOUBLE sqr_min_sep_this_point = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
            if(sqr_min_sep_this_point >= sqr_max_sep) {
                continue;
            }
            max_dz = SQRT(sqr_max_sep - min_dx*min_dx - min_dy*min_dy);

            const DOUBLE target_z = zpos - max_all_dz;
            while(z1 != zend && *z1 <= target_z) {
                z1++;
            }
        }/* end of same_cell if condition*/

        /* are there any pairs possible with this particle and ANY
           of the j'th particles?
           Since both z0 and z1 are sorted in increasing order,
           the largest value for z1 is stored in last_z1. Therefore,
           the smallest difference between ANY of the remaining i'th particle
           and ANY of the j'th particle is:
           the current particle (i.e., the smallest remaining z-position among the 'i'-th dataset)
           and the last j'th particle. Therefore, if this difference is already too large
           to contain a valid pair, any remaining particle pairs CAN NOT be a valid pair

           --> we can safely terminate the i-loop (i.e., terminate the calculation for this pair of
           cells)
        */
        if(z1 == zend) {
            i = N0;
            break;
        }

        DOUBLE *localz1 = z1;
        const DOUBLE target_z = zpos - max_dz;
        while(localz1 != zend && *localz1 <= target_z) {
            localz1++;
        }

        int64_t j = localz1 - zstart;
        DOUBLE *localx1 = x1 + j;
        DOUBLE *localy1 = y1 + j;
        for(int w = 0; w < local_w1.num_weights; w++){
            local_w1.weights[w] = weights1->weights[w] + j;
        }

        const AVX_FLOATS m_xpos = AVX_SET_FLOAT(xpos);
        const AVX_FLOATS m_ypos = AVX_SET_FLOAT(ypos);
        const AVX_FLOATS m_zpos = AVX_SET_FLOAT(zpos);
        const AVX_FLOATS m_xhat0 = AVX_SET_FLOAT(xhat0);
        const AVX_FLOATS m_yhat0 = AVX_SET_FLOAT(yhat0);
        const AVX_FLOATS m_zhat0 = AVX_SET_FLOAT(zhat0);

        const AVX_FLOATS m_sqr_pimax = AVX_SET_FLOAT(sqr_pimax);
        const AVX_FLOATS m_sqr_rpmax = AVX_SET_FLOAT(sqr_rpmax);
        const AVX_FLOATS m_sqr_rpmin = AVX_SET_FLOAT(sqr_rpmin);
        const AVX_FLOATS m_sqr_max_sep = AVX_SET_FLOAT(sqr_max_sep);
        const AVX_FLOATS m_max_dz = AVX_SET_FLOAT(max_dz);
        const AVX_FLOATS m_inv_dpi = AVX_SET_FLOAT(inv_dpi);
        const AVX_FLOATS m_inv_dpi_opp = AVX_SET_FLOAT(-inv_dpi);
        const AVX_FLOATS m_pimin_invstep = AVX_SET_FLOAT(pimin_invstep);
        const AVX_FLOATS m_npibin = AVX_SET_FLOAT((DOUBLE) npibin);
        const AVX_FLOATS m_npibin_p1 = AVX_SET_FLOAT((DOUBLE) npibin + 1);

        for(;j<=(N1-AVX_NVEC);j+=AVX_NVEC){
            const AVX_FLOATS m_x2 = AVX_LOAD_FLOATS_UNALIGNED(localx1);
            const AVX_FLOATS m_y2 = AVX_LOAD_FLOATS_UNALIGNED(localy1);
            const AVX_FLOATS m_z2 = AVX_LOAD_FLOATS_UNALIGNED(localz1);
            AVX_FLOATS m_xhat1, m_yhat1, m_zhat1;
            if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
                m_xhat1 = AVX_LOAD_FLOATS_UNALIGNED(xhat1 + j);
                m_yhat1 = AVX_LOAD_FLOATS_UNALIGNED(yhat1 + j);
                m_zhat1 = AVX_LOAD_FLOATS_UNALIGNED(zhat1 + j);
            }
            union int8 union_finalbin;
            union float8 union_mDperp;
            union float8_weights union_mweight;

            localx1 += AVX_NVEC;
            localy1 += AVX_NVEC;
            localz1 += AVX_NVEC;

            for(int w = 0; w < pair.num_weights; w++){
                pair.weights1[w].a = AVX_LOAD_FLOATS_UNALIGNED(local_w1.weights[w]);
                local_w1.weights[w] += AVX_NVEC;
            }

            const AVX_FLOATS m_perpx = AVX_SUBTRACT_FLOATS(m_x2, m_xpos);
            const AVX_FLOATS m_perpy = AVX_SUBTRACT_FLOATS(m_y2, m_ypos);
            const AVX_FLOATS m_perpz = AVX_SUBTRACT_FLOATS(m_z2, m_zpos);

            const AVX_FLOATS m_parx = AVX_ADD_FLOATS(m_x2, m_xpos);
            const AVX_FLOATS m_pary = AVX_ADD_FLOATS(m_y2, m_ypos);
            const AVX_FLOATS m_parz = AVX_ADD_FLOATS(m_z2, m_zpos);

            /* Since the particles are sorted on 'z', we can check if any of the dz values >= max_dz */
            const AVX_FLOATS m_mask_dz = AVX_COMPARE_FLOATS(m_perpz, m_max_dz, _CMP_GE_OQ);
            if(AVX_TEST_COMPARISON(m_mask_dz) > 0) {
                /* this means the next chunk of particles can not be within 's' */
                j = N1;/* but do not break out of the loop because this chunk might contain valid pairs */
            }

            AVX_FLOATS m_sqr_sep;
            {
                const AVX_FLOATS m_sqr_perpx = AVX_SQUARE_FLOAT(m_perpx);
                const AVX_FLOATS m_sqr_perpy = AVX_SQUARE_FLOAT(m_perpy);
                const AVX_FLOATS m_sqr_perpz = AVX_SQUARE_FLOAT(m_perpz);
                m_sqr_sep = AVX_ADD_FLOATS(m_sqr_perpx, AVX_ADD_FLOATS(m_sqr_perpy, m_sqr_perpz));//3-d separation
            }

            const AVX_FLOATS m_mask_sep = AVX_COMPARE_FLOATS(m_sqr_sep, m_sqr_max_sep, _CMP_LT_OQ);
            if(AVX_TEST_COMPARISON(m_mask_sep) == 0) continue;

            AVX_FLOATS m_sqr_Dperp, m_sqr_Dperp2, m_pibin, m_pibin2, m_mask_left, m_mask_left2;
            if (los_type == MIDPOINT_LOS) {
                const AVX_FLOATS m_s_dot_l = AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_parx, m_perpx), AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_pary, m_perpy), AVX_MULTIPLY_FLOATS(m_parz, m_perpz)));
                const AVX_FLOATS m_sqr_l = AVX_ADD_FLOATS(AVX_SQUARE_FLOAT(m_parx), AVX_ADD_FLOATS(AVX_SQUARE_FLOAT(m_pary), AVX_SQUARE_FLOAT(m_parz)));
                const AVX_FLOATS m_sqr_pimax_times_sqr_l = AVX_MULTIPLY_FLOATS(m_sqr_pimax, m_sqr_l);
                const AVX_FLOATS m_sqr_s_dot_l = AVX_SQUARE_FLOAT(m_s_dot_l);
                const AVX_FLOATS m_mask_pimax_sep = AVX_COMPARE_FLOATS(m_sqr_s_dot_l, m_sqr_pimax_times_sqr_l, _CMP_LT_OQ);// is pi < pimax ?
                m_mask_left = AVX_BITWISE_AND(m_mask_sep, m_mask_pimax_sep);
                if(AVX_TEST_COMPARISON(m_mask_left) == 0) continue;
                AVX_FLOATS m_sqr_Dpar = AVX_SETZERO_FLOAT();
                CHECK_AND_FAST_DIVIDE_AVX(m_sqr_Dpar, m_sqr_s_dot_l, m_sqr_l, fast_divide_and_NR_steps);
                m_sqr_Dperp = AVX_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar);
                const AVX_FLOATS m_rpmax_mask = AVX_COMPARE_FLOATS(m_sqr_Dperp, m_sqr_rpmax, _CMP_LT_OQ);
                const AVX_FLOATS m_rpmin_mask = AVX_COMPARE_FLOATS(m_sqr_Dperp, m_sqr_rpmin, _CMP_GE_OQ);
                m_mask_left = AVX_BITWISE_AND(m_mask_pimax_sep, AVX_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if(AVX_TEST_COMPARISON(m_mask_left) == 0) continue;
                const AVX_FLOATS m_pi = AVX_SIGNED_FLOATS(AVX_SQRT_FLOAT(m_sqr_Dpar), m_s_dot_l);
                m_pibin = AVX_BLEND_FLOATS_WITH_MASK(m_npibin, AVX_FMA_ADD_TRUNCATE_FLOATS(m_pi, m_inv_dpi, m_pimin_invstep), m_mask_left);
                if (autocorr == 1) m_pibin2 = AVX_BLEND_FLOATS_WITH_MASK(m_npibin, AVX_FMA_ADD_TRUNCATE_FLOATS(m_pi, m_inv_dpi_opp, m_pimin_invstep), m_mask_left);
            }
            else {
                const AVX_FLOATS m_s_dot_l = AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_xhat0, m_perpx), AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_yhat0, m_perpy), AVX_MULTIPLY_FLOATS(m_zhat0, m_perpz)));
                const AVX_FLOATS m_sqr_Dpar = AVX_SQUARE_FLOAT(m_s_dot_l);
                const AVX_FLOATS m_mask_pimax_sep = AVX_COMPARE_FLOATS(m_sqr_Dpar, m_sqr_pimax, _CMP_LT_OQ);// is pi < pimax ?
                m_sqr_Dperp = AVX_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar);
                const AVX_FLOATS m_rpmax_mask = AVX_COMPARE_FLOATS(m_sqr_Dperp, m_sqr_rpmax, _CMP_LT_OQ);
                const AVX_FLOATS m_rpmin_mask = AVX_COMPARE_FLOATS(m_sqr_Dperp, m_sqr_rpmin, _CMP_GE_OQ);
                m_mask_left = AVX_BITWISE_AND(m_mask_pimax_sep, AVX_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if (autocorr == 1) {
                    const AVX_FLOATS m_s_dot_l2 = AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_xhat1, m_perpx), AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_yhat1, m_perpy), AVX_MULTIPLY_FLOATS(m_zhat1, m_perpz)));
                    const AVX_FLOATS m_sqr_Dpar2 = AVX_SQUARE_FLOAT(m_s_dot_l2);
                    const AVX_FLOATS m_mask_pimax_sep2 = AVX_COMPARE_FLOATS(m_sqr_Dpar2, m_sqr_pimax, _CMP_LT_OQ);// is pi < pimax ?
                    m_sqr_Dperp2 = AVX_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar2);
                    const AVX_FLOATS m_rpmax_mask2 = AVX_COMPARE_FLOATS(m_sqr_Dperp2, m_sqr_rpmax, _CMP_LT_OQ);
                    const AVX_FLOATS m_rpmin_mask2 = AVX_COMPARE_FLOATS(m_sqr_Dperp2, m_sqr_rpmin, _CMP_GE_OQ);
                    m_mask_left2 = AVX_BITWISE_AND(m_mask_pimax_sep2, AVX_BITWISE_AND(m_rpmax_mask2, m_rpmin_mask2));
                    //if (AVX_TEST_COMPARISON(AVX_BITWISE_OR(m_mask_left, m_mask_left2)) == 0) continue;
                    m_pibin = AVX_BLEND_FLOATS_WITH_MASK(m_npibin, AVX_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l, m_inv_dpi, m_pimin_invstep), m_mask_left);
                    m_pibin2 = AVX_BLEND_FLOATS_WITH_MASK(m_npibin, AVX_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l2, m_inv_dpi_opp, m_pimin_invstep), m_mask_left2);
                }
                else {
                    if (AVX_TEST_COMPARISON(m_mask_left) == 0) continue;
                    m_pibin = AVX_BLEND_FLOATS_WITH_MASK(m_npibin, AVX_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l, m_inv_dpi, m_pimin_invstep), m_mask_left);
                }
            }

            if(need_costheta) pair.costheta.a = AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(m_xhat0, m_xhat1), AVX_MULTIPLY_FLOATS(m_yhat0, m_yhat1)), AVX_MULTIPLY_FLOATS(m_zhat0, m_zhat1));

            if(need_weightavg){
                pair.dx.a = m_perpx;
                pair.dy.a = m_perpy;
                pair.dz.a = m_perpz;

                pair.parx.a = m_parx;
                pair.pary.a = m_pary;
                pair.parz.a = m_parz;

                union_mweight.m_weights = avx_weight_func(&pair);
            }

            if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = AVX_SQRT_FLOAT(m_sqr_Dperp);
            AVX_FLOATS m_rpbin = AVX_SETZERO_FLOAT();
            if (bin_type == BIN_LIN) {
                m_rpbin = AVX_BLEND_FLOATS_WITH_MASK(m_rpbin, AVX_FMA_ADD_TRUNCATE_FLOATS(union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep), m_mask_left);
            }
            else {
                for(int kbin=nbin-1;kbin>=1;kbin--) {
                    const AVX_FLOATS m_mask_low = AVX_COMPARE_FLOATS(m_sqr_Dperp, m_rupp_sqr[kbin-1], _CMP_GE_OQ);
                    const AVX_FLOATS m_bin_mask = AVX_BITWISE_AND(m_mask_low, m_mask_left);
                    m_rpbin = AVX_BLEND_FLOATS_WITH_MASK(m_rpbin, m_kbin[kbin], m_bin_mask);
                    m_mask_left = AVX_AND_NOT(m_bin_mask, m_mask_left);/* (not kbin) and mask_left */
                    if(AVX_TEST_COMPARISON(m_mask_left) == 0) {
                        break;
                    }
                }
            }
            /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
            /*                      const AVX_FLOATS m_Dpar = AVX_SQRT_FLOAT(m_sqr_Dpar); */

            m_rpbin = AVX_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);  // already blended with mask (npibin)
            union_finalbin.m_ibin = AVX_TRUNCATE_FLOAT_TO_INT(AVX_ADD_FLOATS(m_rpbin, m_pibin));
            if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = AVX_MULTIPLY_FLOATS(union_mDperp.m_Dperp, union_mweight.m_weights);

#if  __INTEL_COMPILER
#pragma unroll(AVX_NVEC)
#endif
            for(int jj=0;jj<AVX_NVEC;jj++) {
                const int ibin = union_finalbin.ibin[jj];
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
            }

            if (autocorr == 1) {
                if (los_type == MIDPOINT_LOS) {
                    union_finalbin.m_ibin = AVX_TRUNCATE_FLOAT_TO_INT(AVX_ADD_FLOATS(m_rpbin, m_pibin2));
                }
                else {
                    if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = AVX_SQRT_FLOAT(m_sqr_Dperp2);
                    m_rpbin = AVX_SETZERO_FLOAT();
                    if (bin_type == BIN_LIN) {
                        m_rpbin = AVX_BLEND_FLOATS_WITH_MASK(m_rpbin, AVX_FMA_ADD_TRUNCATE_FLOATS(union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep), m_mask_left2);
                    }
                    else {
                        for(int kbin=nbin-1;kbin>=1;kbin--) {
                            const AVX_FLOATS m_mask_low = AVX_COMPARE_FLOATS(m_sqr_Dperp2, m_rupp_sqr[kbin-1], _CMP_GE_OQ);
                            const AVX_FLOATS m_bin_mask = AVX_BITWISE_AND(m_mask_low, m_mask_left2);
                            m_rpbin = AVX_BLEND_FLOATS_WITH_MASK(m_rpbin, m_kbin[kbin], m_bin_mask);
                            m_mask_left2 = AVX_AND_NOT(m_bin_mask, m_mask_left2);/* (not kbin) and mask_left */
                            if(AVX_TEST_COMPARISON(m_mask_left2) == 0) {
                                break;
                            }
                        }
                    }
                    /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
                    m_rpbin = AVX_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);
                    union_finalbin.m_ibin = AVX_TRUNCATE_FLOAT_TO_INT(AVX_ADD_FLOATS(m_rpbin, m_pibin2));
                    if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = AVX_MULTIPLY_FLOATS(union_mDperp.m_Dperp, union_mweight.m_weights);
                }
#if  __INTEL_COMPILER
#pragma unroll(AVX_NVEC)
#endif
                for(int jj=0;jj<AVX_NVEC;jj++) {
                    const int ibin = union_finalbin.ibin[jj];
                    npairs[ibin]++;
                    if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                    if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
                }
            }
        }

        //Take care of the remainder
        for(;j<N1;j++) {

            if(need_costheta) pair.costheta.d = xhat1[j]*xhat0 + yhat1[j]*yhat0 + zhat1[j]*zhat0;

            const DOUBLE parx = xpos + *localx1;
            const DOUBLE pary = ypos + *localy1;
            const DOUBLE parz = zpos + *localz1;

            const DOUBLE perpx = *localx1++ - xpos;
            const DOUBLE perpy = *localy1++ - ypos;
            const DOUBLE perpz = *localz1++ - zpos;

            for(int w = 0; w < pair.num_weights; w++){
                pair.weights1[w].d = *local_w1.weights[w]++;
            }

            if(perpz >= max_dz) break;

            const DOUBLE sqr_s = perpx*perpx + perpy*perpy + perpz*perpz;
            if(sqr_s >= sqr_max_sep) continue;

            DOUBLE sqr_Dpar = ZERO, sqr_Dpar2 = ZERO;
            DOUBLE sqr_Dperp = ZERO, sqr_Dperp2 = ZERO;
            DOUBLE rp = ZERO, rp2 = ZERO;
            int pibin = npibin, pibin2 = npibin;
            if (sqr_s <= 0.) {
                pibin2 = pibin = (int) pimin_invstep;
            }
            else if (los_type == MIDPOINT_LOS) {
                const DOUBLE s_dot_l = parx*perpx + pary*perpy + parz*perpz;
                const DOUBLE sqr_l = parx*parx + pary*pary + parz*parz;
                const DOUBLE sqr_s_dot_l = s_dot_l * s_dot_l;
                if (sqr_s_dot_l >= sqr_l * sqr_pimax) continue;
                sqr_Dpar = sqr_s_dot_l / sqr_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                if(sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin) continue;
                const DOUBLE pi = SIGNED(SQRT(sqr_Dpar), s_dot_l);
                pibin = (int) (pi * inv_dpi + pimin_invstep);
                if (autocorr == 1) pibin2 = (int) (- pi * inv_dpi + pimin_invstep);
                if(need_rpavg || bin_type == BIN_LIN) rp = rp2 = SQRT(sqr_Dperp);
            }
            else {
                const DOUBLE s_dot_l = xhat0*perpx + yhat0*perpy + zhat0*perpz;
                sqr_Dpar = s_dot_l * s_dot_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                const int skip_pi = (sqr_Dpar >= sqr_pimax) || (sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin);
                if (autocorr == 1) {
                    const DOUBLE s_dot_l2 = xhat1[j]*perpx + yhat1[j]*perpy + zhat1[j]*perpz;
                    sqr_Dpar2 = s_dot_l2 * s_dot_l2;
                    sqr_Dperp2 = sqr_s - sqr_Dpar2;
                    const int skip_pi2 = (sqr_Dpar2 >= sqr_pimax) || (sqr_Dperp2 >= sqr_rpmax || sqr_Dperp2 < sqr_rpmin);
                    if (skip_pi && skip_pi2) continue;
                    if (skip_pi == 0) {
                        pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                    }
                    if (skip_pi2 == 0) {
                        pibin2 = (int) (- s_dot_l2 * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp2 = SQRT(sqr_Dperp2);
                    }
                }
                else {
                    if (skip_pi) continue;
                    pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                    if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                }
            }

            DOUBLE pairweight = ZERO;
            DOUBLE rpw = rp, rpw2 = rp2;

            if(need_weightavg){
                pair.dx.d = perpx;
                pair.dy.d = perpy;
                pair.dz.d = perpz;

                pair.parx.d = parx;
                pair.pary.d = pary;
                pair.parz.d = parz;

                pairweight = fallback_weight_func(&pair);
                if(need_rpavg) {
                   rpw = rp*pairweight;
                   if (autocorr == 1) rpw2 = rp2*pairweight;
                }
            }
            int kbin = 0;
            if (bin_type == BIN_LIN) kbin = (int) (rp*inv_rpstep + rpmin_invstep);
            else {
                for(kbin=nbin-1;kbin>=1;kbin--) {
                    if(sqr_Dperp >= rupp_sqr[kbin-1]) break;
                }//finding kbin
            }
            kbin *= npibin + 1;
            {
                const int ibin = kbin + pibin;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
            if (autocorr == 1) {
                if (los_type == FIRSTPOINT_LOS) {
                    if (bin_type == BIN_LIN) kbin = (int) (rp2*inv_rpstep + rpmin_invstep);
                    else {
                        for(kbin=nbin-1;kbin>=1;kbin--) {
                            if(sqr_Dperp2 >= rupp_sqr[kbin-1]) break;
                        }//finding kbin
                    }
                    kbin *= npibin + 1;
                }
                const int ibin = kbin + pibin2;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw2;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
        }//remainder jloop
    }//i-loop

    free(xhat1); free(yhat1); free(zhat1);

    return EXIT_SUCCESS;
}
#endif //AVX defined




#if defined(__SSE4_2__)
#include "sse_calls.h"

static inline int countpairs_rp_pi_mocks_sse_intrinsics_DOUBLE(const int64_t N0, DOUBLE *x0, DOUBLE *y0, DOUBLE *z0,
                                                               const weight_struct_DOUBLE *weights0,
                                                               const int64_t N1, DOUBLE *x1, DOUBLE *y1, DOUBLE *z1,
                                                               const weight_struct_DOUBLE *weights1,
                                                               const int same_cell,
                                                               const unsigned int fast_divide_and_NR_steps,
                                                               const DOUBLE rpmax, const DOUBLE rpmin, const int nbin, const int npibin,
                                                               const DOUBLE *rupp_sqr, const DOUBLE pimax,
                                                               const DOUBLE min_xdiff, const DOUBLE min_ydiff, const DOUBLE min_zdiff,
                                                               const DOUBLE closest_icell_xpos, const DOUBLE closest_icell_ypos,
                                                               const DOUBLE closest_icell_zpos,
                                                               DOUBLE *rpavg,
                                                               uint64_t *npairs,
                                                               DOUBLE *weightavg, const weight_method_t weight_method, const pair_weight_struct pair_weight,
                                                               const bin_type_t bin_type, const los_type_t los_type, const int autocorr)
{
    if(N0 == 0 || N1 == 0) {
        return EXIT_SUCCESS;
    }
    if(npairs == NULL) {
        return EXIT_FAILURE;
    }

    const int32_t need_rpavg = rpavg != NULL;
    const int32_t need_weightavg = weightavg != NULL;
    int32_t need_costheta = need_weightavg;
    const DOUBLE sqr_rpmin=rpmin*rpmin, sqr_rpmax=rpmax*rpmax;
    DOUBLE inv_rpstep=0., rpmin_invstep=0.;
    SSE_FLOATS m_inv_rpstep = SSE_SETZERO_FLOAT();
    SSE_FLOATS m_rpmin_invstep = SSE_SETZERO_FLOAT();
    if (bin_type == BIN_LIN) {
        inv_rpstep = (nbin - 1)/(rpmax - rpmin);
        rpmin_invstep = 1 - rpmin*inv_rpstep; //trick to avoid adding one to (r - rmin)/rstep
        m_inv_rpstep = SSE_SET_FLOAT(inv_rpstep);
        m_rpmin_invstep = SSE_SET_FLOAT(rpmin_invstep);
    }

    (void) fast_divide_and_NR_steps; //unused

    SSE_FLOATS m_rupp_sqr[nbin];
    for(int i=0;i<nbin;i++) {
        m_rupp_sqr[i] = SSE_SET_FLOAT(rupp_sqr[i]);
    }
    SSE_FLOATS m_kbin[nbin];
    for(int i=0;i<nbin;i++) {
        m_kbin[i] = SSE_SET_FLOAT((DOUBLE) i);
    }

    const DOUBLE sqr_max_sep = sqr_rpmax + pimax*pimax;
    const DOUBLE sqr_pimax = pimax*pimax;

    const DOUBLE inv_dpi = ((DOUBLE) npibin)/(2*pimax);
    const DOUBLE pimin_invstep = pimax*inv_dpi;

    // A copy whose pointers we can advance
    weight_struct_DOUBLE local_w0 = {.weights={NULL}, .num_weights=0}, local_w1 = {.weights={NULL}, .num_weights=0};
    pair_struct_DOUBLE pair = {.num_weights=0};
    sse_weight_func_t_DOUBLE sse_weight_func = NULL;
    weight_func_t_DOUBLE fallback_weight_func = NULL;
    if(need_weightavg){
      // Same particle list, new copy of num_weights pointers into that list
      local_w0 = *weights0;
      local_w1 = *weights1;

      set_pair_struct_DOUBLE(&pair, &local_w0, &local_w1, &pair_weight);
      need_costheta = pair_weight.num;
      sse_weight_func = get_sse_weight_func_by_method_DOUBLE(weight_method);
      fallback_weight_func = get_weight_func_by_method_DOUBLE(weight_method);
    }
    DOUBLE *xhat1 = NULL, *yhat1 = NULL, *zhat1 = NULL;
    if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
        xhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        yhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        zhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        for(int64_t i=0;i<N1;i++) {
            const DOUBLE norm1 = SQRT(x1[i]*x1[i] + y1[i]*y1[i] + z1[i]*z1[i]);
            xhat1[i] = x1[i]/norm1;
            yhat1[i] = y1[i]/norm1;
            zhat1[i] = z1[i]/norm1;
        }
    }

    const DOUBLE *zstart = z1, *zend = z1 + N1;
    const DOUBLE max_all_dz = SQRT(sqr_max_sep - min_xdiff*min_xdiff - min_ydiff*min_ydiff);
    for(int64_t i=0;i<N0;i++) {
        const DOUBLE xpos = *x0++;
        const DOUBLE ypos = *y0++;
        const DOUBLE zpos = *z0++;
        for(int w = 0; w < pair.num_weights; w++){
            // local_w0.weights[w] is a pointer to a float in the particle list of weights,
            // just as x0 is a pointer into the list of x-positions.
            // The advancement of the local_w0.weights[w] pointer should always mirror x0.
            pair.weights0[w].s = SSE_SET_FLOAT(*local_w0.weights[w]++);
        }
        DOUBLE xhat0 = ZERO, yhat0 = ZERO, zhat0 = ZERO;
        if (need_costheta || los_type == FIRSTPOINT_LOS) {
            const DOUBLE norm0 = SQRT(xpos*xpos + ypos*ypos + zpos*zpos);
            xhat0 = xpos/norm0;
            yhat0 = ypos/norm0;
            zhat0 = zpos/norm0;
        }

        DOUBLE max_dz = max_all_dz;

        /* Now consider if this i'th particle can be a valid pair with ANY of the remaining
           j' particles. The min. difference in the d-positions between this i'th particle and ANY
           of the remaining j'th particles, is the difference between the current j'th particle and
           the current i'th particle (since all remaining j'th particles will have a larger value for
           the z-ordinate and therefore a larger difference to zpos). if this `dsep` does not satisfy
           the distance criteria, then NO remaining j'th particles will. Continue on to the next i'th
           particle
        */
        const DOUBLE this_dz = *z1 - zpos;
        if(this_dz >= max_all_dz) {
            continue;
        }

        if(same_cell == 1) {
            z1++;
        } else {
            const DOUBLE min_dx = min_xdiff > 0 ? min_xdiff + FABS(xpos - closest_icell_xpos):min_xdiff;
            const DOUBLE min_dy = min_ydiff > 0 ? min_ydiff + FABS(ypos - closest_icell_ypos):min_ydiff;
            const DOUBLE min_dz = min_zdiff > 0 ? (this_dz > 0 ? this_dz:min_zdiff + FABS(zpos - closest_icell_zpos)):min_zdiff;
            const DOUBLE sqr_min_sep_this_point = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
            if(sqr_min_sep_this_point >= sqr_max_sep) {
                continue;
            }
            max_dz = SQRT(sqr_max_sep - min_dx*min_dx - min_dy*min_dy);

            const DOUBLE target_z = zpos - max_all_dz;
            while(z1 != zend && *z1 <= target_z) {
                z1++;
            }
        }/* end of same_cell if condition*/


        /* are there any pairs possible with this particle and ANY
           of the j'th particles?
           Since both z0 and z1 are sorted in increasing order,
           the largest value for z1 is stored in last_z1. Therefore,
           the smallest difference between ANY of the remaining i'th particle
           and ANY of the j'th particle is:
           the current particle (i.e., the smallest remaining z-position among the 'i'-th dataset)
           and the last j'th particle. Therefore, if this difference is already too large
           to contain a valid pair, any remaining particle pairs CAN NOT be a valid pair

           --> we can safely terminate the i-loop (i.e., terminate the calculation for this pair of
           cells)
        */
        if(z1 == zend) {
            i = N0;
            break;
        }

        DOUBLE *localz1 = z1;
        const DOUBLE target_z = zpos - max_dz;
        while(localz1 != zend && *localz1 <= target_z) {
            localz1++;
        }

        int64_t j = localz1 - zstart;
        DOUBLE *localx1 = x1 + j;
        DOUBLE *localy1 = y1 + j;
        for(int w = 0; w < local_w1.num_weights; w++){
            local_w1.weights[w] = weights1->weights[w] + j;
        }

        const SSE_FLOATS m_xpos = SSE_SET_FLOAT(xpos);
        const SSE_FLOATS m_ypos = SSE_SET_FLOAT(ypos);
        const SSE_FLOATS m_zpos = SSE_SET_FLOAT(zpos);
        const SSE_FLOATS m_xhat0 = SSE_SET_FLOAT(xhat0);
        const SSE_FLOATS m_yhat0 = SSE_SET_FLOAT(yhat0);
        const SSE_FLOATS m_zhat0 = SSE_SET_FLOAT(zhat0);

        const SSE_FLOATS m_sqr_pimax = SSE_SET_FLOAT(sqr_pimax);
        const SSE_FLOATS m_sqr_rpmax = SSE_SET_FLOAT(sqr_rpmax);
        const SSE_FLOATS m_sqr_rpmin = SSE_SET_FLOAT(sqr_rpmin);
        const SSE_FLOATS m_sqr_max_sep = SSE_SET_FLOAT(sqr_max_sep);
        const SSE_FLOATS m_max_dz = SSE_SET_FLOAT(max_dz);
        const SSE_FLOATS m_inv_dpi = SSE_SET_FLOAT(inv_dpi);
        const SSE_FLOATS m_inv_dpi_opp = SSE_SET_FLOAT(-inv_dpi);
        const SSE_FLOATS m_pimin_invstep = SSE_SET_FLOAT(pimin_invstep);
        const SSE_FLOATS m_npibin = SSE_SET_FLOAT((DOUBLE) npibin);
        const SSE_FLOATS m_npibin_p1 = SSE_SET_FLOAT((DOUBLE) npibin + 1);

        for(;j<=(N1-SSE_NVEC);j+=SSE_NVEC){
            const SSE_FLOATS m_x2 = SSE_LOAD_FLOATS_UNALIGNED(localx1);
            const SSE_FLOATS m_y2 = SSE_LOAD_FLOATS_UNALIGNED(localy1);
            const SSE_FLOATS m_z2 = SSE_LOAD_FLOATS_UNALIGNED(localz1);
            SSE_FLOATS m_xhat1, m_yhat1, m_zhat1;
            if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
                m_xhat1 = SSE_LOAD_FLOATS_UNALIGNED(xhat1 + j);
                m_yhat1 = SSE_LOAD_FLOATS_UNALIGNED(yhat1 + j);
                m_zhat1 = SSE_LOAD_FLOATS_UNALIGNED(zhat1 + j);
            }

            union int4 union_finalbin;
            union float4 union_mDperp;
            union float4_weights union_mweight;

            localx1 += SSE_NVEC;
            localy1 += SSE_NVEC;
            localz1 += SSE_NVEC;
            for(int w = 0; w < pair.num_weights; w++){
                pair.weights1[w].s = SSE_LOAD_FLOATS_UNALIGNED(local_w1.weights[w]);
                local_w1.weights[w] += SSE_NVEC;
            }

            const SSE_FLOATS m_perpx = SSE_SUBTRACT_FLOATS(m_x2, m_xpos);
            const SSE_FLOATS m_perpy = SSE_SUBTRACT_FLOATS(m_y2, m_ypos);
            const SSE_FLOATS m_perpz = SSE_SUBTRACT_FLOATS(m_z2, m_zpos);

            const SSE_FLOATS m_mask_dz = SSE_COMPARE_FLOATS_GE(m_perpz, m_max_dz);
            if(SSE_TEST_COMPARISON(m_mask_dz) > 0 ) {
                /* this means the next chunk of particles can not be within 's' */
                j = N1;/* but do not break out of the loop because this chunk might contain valid pairs */
            }

            const SSE_FLOATS m_parx = SSE_ADD_FLOATS(m_x2, m_xpos);
            const SSE_FLOATS m_pary = SSE_ADD_FLOATS(m_y2, m_ypos);
            const SSE_FLOATS m_parz = SSE_ADD_FLOATS(m_z2, m_zpos);

            SSE_FLOATS m_sqr_sep;
            {
                const SSE_FLOATS m_sqr_perpx = SSE_SQUARE_FLOAT(m_perpx);
                const SSE_FLOATS m_sqr_perpy = SSE_SQUARE_FLOAT(m_perpy);
                const SSE_FLOATS m_sqr_perpz = SSE_SQUARE_FLOAT(m_perpz);
                m_sqr_sep = SSE_ADD_FLOATS(m_sqr_perpx, SSE_ADD_FLOATS(m_sqr_perpy, m_sqr_perpz));//3-d separation
            }

            const SSE_FLOATS m_mask_sep = SSE_COMPARE_FLOATS_LT(m_sqr_sep, m_sqr_max_sep);
            if(SSE_TEST_COMPARISON(m_mask_sep) == 0) continue;

            SSE_FLOATS m_sqr_Dperp, m_sqr_Dperp2, m_pibin, m_pibin2, m_mask_left, m_mask_left2;
            if (los_type == MIDPOINT_LOS) {
                const SSE_FLOATS m_s_dot_l = SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_parx, m_perpx), SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_pary, m_perpy), SSE_MULTIPLY_FLOATS(m_parz, m_perpz)));
                const SSE_FLOATS m_sqr_l = SSE_ADD_FLOATS(SSE_SQUARE_FLOAT(m_parx), SSE_ADD_FLOATS(SSE_SQUARE_FLOAT(m_pary), SSE_SQUARE_FLOAT(m_parz)));
                const SSE_FLOATS m_sqr_pimax_times_sqr_l = SSE_MULTIPLY_FLOATS(m_sqr_pimax, m_sqr_l);
                const SSE_FLOATS m_sqr_s_dot_l = SSE_SQUARE_FLOAT(m_s_dot_l);
                const SSE_FLOATS m_mask_pimax_sep = SSE_COMPARE_FLOATS_LT(m_sqr_s_dot_l, m_sqr_pimax_times_sqr_l);// is pi < pimax ?
                m_mask_left = SSE_BITWISE_AND(m_mask_sep, m_mask_pimax_sep);
                if(SSE_TEST_COMPARISON(m_mask_left) == 0) continue;
                const SSE_FLOATS m_sqr_Dpar = SSE_DIVIDE_FLOATS(m_sqr_s_dot_l, m_sqr_l);
                m_sqr_Dperp = SSE_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar);
                const SSE_FLOATS m_rpmax_mask = SSE_COMPARE_FLOATS_LT(m_sqr_Dperp, m_sqr_rpmax);
                const SSE_FLOATS m_rpmin_mask = SSE_COMPARE_FLOATS_GE(m_sqr_Dperp, m_sqr_rpmin);
                m_mask_left = SSE_BITWISE_AND(m_mask_pimax_sep, SSE_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if(SSE_TEST_COMPARISON(m_mask_left) == 0) continue;
                const SSE_FLOATS m_pi = SSE_SIGNED_FLOATS(SSE_SQRT_FLOAT(m_sqr_Dpar), m_s_dot_l);
                m_pibin = SSE_BLEND_FLOATS_WITH_MASK(m_npibin, SSE_FMA_ADD_TRUNCATE_FLOATS(m_pi, m_inv_dpi, m_pimin_invstep), m_mask_left);
                if (autocorr == 1) m_pibin2 = SSE_BLEND_FLOATS_WITH_MASK(m_npibin, SSE_FMA_ADD_TRUNCATE_FLOATS(m_pi, m_inv_dpi_opp, m_pimin_invstep), m_mask_left);
            }
            else {
                const SSE_FLOATS m_s_dot_l = SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_xhat0, m_perpx), SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_yhat0, m_perpy), SSE_MULTIPLY_FLOATS(m_zhat0, m_perpz)));
                const SSE_FLOATS m_sqr_Dpar = SSE_SQUARE_FLOAT(m_s_dot_l);
                const SSE_FLOATS m_mask_pimax_sep = SSE_COMPARE_FLOATS_LT(m_sqr_Dpar, m_sqr_pimax);// is pi < pimax ?
                m_sqr_Dperp = SSE_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar);
                const SSE_FLOATS m_rpmax_mask = SSE_COMPARE_FLOATS_LT(m_sqr_Dperp, m_sqr_rpmax);
                const SSE_FLOATS m_rpmin_mask = SSE_COMPARE_FLOATS_GE(m_sqr_Dperp, m_sqr_rpmin);
                m_mask_left = SSE_BITWISE_AND(m_mask_pimax_sep, SSE_BITWISE_AND(m_rpmax_mask, m_rpmin_mask));
                if (autocorr == 1) {
                    const SSE_FLOATS m_s_dot_l2 = SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_xhat1, m_perpx), SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_yhat1, m_perpy), SSE_MULTIPLY_FLOATS(m_zhat1, m_perpz)));
                    const SSE_FLOATS m_sqr_Dpar2 = SSE_SQUARE_FLOAT(m_s_dot_l2);
                    const SSE_FLOATS m_mask_pimax_sep2 = SSE_COMPARE_FLOATS_LT(m_sqr_Dpar2, m_sqr_pimax);// is pi < pimax ?
                    m_sqr_Dperp2 = SSE_SUBTRACT_FLOATS(m_sqr_sep, m_sqr_Dpar2);
                    const SSE_FLOATS m_rpmax_mask2 = SSE_COMPARE_FLOATS_LT(m_sqr_Dperp2, m_sqr_rpmax);
                    const SSE_FLOATS m_rpmin_mask2 = SSE_COMPARE_FLOATS_GE(m_sqr_Dperp2, m_sqr_rpmin);
                    m_mask_left2 = SSE_BITWISE_AND(m_mask_pimax_sep2, SSE_BITWISE_AND(m_rpmax_mask2, m_rpmin_mask2));
                    //if (SSE_TEST_COMPARISON(SSE_BITWISE_OR(m_mask_left, m_mask_left2)) == 0) continue;
                    m_pibin = SSE_BLEND_FLOATS_WITH_MASK(m_npibin, SSE_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l, m_inv_dpi, m_pimin_invstep), m_mask_left);
                    m_pibin2 = SSE_BLEND_FLOATS_WITH_MASK(m_npibin, SSE_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l2, m_inv_dpi_opp, m_pimin_invstep), m_mask_left2);
                }
                else {
                    if (SSE_TEST_COMPARISON(m_mask_left) == 0) continue;
                    m_pibin = SSE_BLEND_FLOATS_WITH_MASK(m_npibin, SSE_FMA_ADD_TRUNCATE_FLOATS(m_s_dot_l, m_inv_dpi, m_pimin_invstep), m_mask_left);
                }
            }

            if(need_costheta) pair.costheta.s = SSE_ADD_FLOATS(SSE_ADD_FLOATS(SSE_MULTIPLY_FLOATS(m_xhat0, m_xhat1), SSE_MULTIPLY_FLOATS(m_yhat0, m_yhat1)), SSE_MULTIPLY_FLOATS(m_zhat0, m_zhat1));

            if(need_weightavg){
                pair.dx.s = m_perpx;
                pair.dy.s = m_perpy;
                pair.dz.s = m_perpz;

                pair.parx.s = m_parx;
                pair.pary.s = m_pary;
                pair.parz.s = m_parz;

                union_mweight.m_weights = sse_weight_func(&pair);
            }

            if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = SSE_SQRT_FLOAT(m_sqr_Dperp);
            SSE_FLOATS m_rpbin = SSE_SETZERO_FLOAT();
            if (bin_type == BIN_LIN) {
                m_rpbin = SSE_BLEND_FLOATS_WITH_MASK(m_rpbin, SSE_FMA_ADD_TRUNCATE_FLOATS(union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep), m_mask_left);
            }
            else {
                for(int kbin=nbin-1;kbin>=1;kbin--) {
                    const SSE_FLOATS m_mask_low = SSE_COMPARE_FLOATS_GE(m_sqr_Dperp, m_rupp_sqr[kbin-1]);
                    const SSE_FLOATS m_bin_mask = SSE_BITWISE_AND(m_mask_low, m_mask_left);
                    m_rpbin = SSE_BLEND_FLOATS_WITH_MASK(m_rpbin, m_kbin[kbin], m_bin_mask);
                    m_mask_left = SSE_COMPARE_FLOATS_LT(m_sqr_Dperp, m_rupp_sqr[kbin-1]);
                    if(SSE_TEST_COMPARISON(m_mask_left) == 0) {
                        break;
                    }
                }
            }
            /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
            /*                      const SSE_FLOATS m_Dpar = SSE_SQRT_FLOAT(m_sqr_Dpar); */

            m_rpbin = SSE_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);  // already blended with mask (npibin)
            union_finalbin.m_ibin = SSE_TRUNCATE_FLOAT_TO_INT(SSE_ADD_FLOATS(m_rpbin, m_pibin));
            if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = SSE_MULTIPLY_FLOATS(union_mDperp.m_Dperp, union_mweight.m_weights);

            #if  __INTEL_COMPILER
            #pragma unroll(SSE_NVEC)
            #endif
            for(int jj=0;jj<SSE_NVEC;jj++) {
                const int ibin = union_finalbin.ibin[jj];
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
            }

            if (autocorr == 1) {
                if (los_type == MIDPOINT_LOS) {
                    union_finalbin.m_ibin = SSE_TRUNCATE_FLOAT_TO_INT(SSE_ADD_FLOATS(m_rpbin, m_pibin2));
                }
                else {
                    if (need_rpavg || bin_type == BIN_LIN) union_mDperp.m_Dperp = SSE_SQRT_FLOAT(m_sqr_Dperp2);
                    m_rpbin = SSE_SETZERO_FLOAT();
                    if (bin_type == BIN_LIN) {
                        m_rpbin = SSE_BLEND_FLOATS_WITH_MASK(m_rpbin, SSE_FMA_ADD_TRUNCATE_FLOATS(union_mDperp.m_Dperp, m_inv_rpstep, m_rpmin_invstep), m_mask_left2);
                    }
                    else {
                        for(int kbin=nbin-1;kbin>=1;kbin--) {
                            const SSE_FLOATS m_mask_low = SSE_COMPARE_FLOATS_GE(m_sqr_Dperp2, m_rupp_sqr[kbin-1]);
                            const SSE_FLOATS m_bin_mask = SSE_BITWISE_AND(m_mask_low, m_mask_left2);
                            m_rpbin = SSE_BLEND_FLOATS_WITH_MASK(m_rpbin, m_kbin[kbin], m_bin_mask);
                            m_mask_left2 = SSE_COMPARE_FLOATS_LT(m_sqr_Dperp2, m_rupp_sqr[kbin-1]);
                            if(SSE_TEST_COMPARISON(m_mask_left2) == 0) {
                                break;
                            }
                        }
                    }
                    /* Compute the 1-D index to the [rpbin, pibin] := rpbin*(npibin+1) + pibin */
                    m_rpbin = SSE_MULTIPLY_FLOATS(m_rpbin, m_npibin_p1);
                    union_finalbin.m_ibin = SSE_TRUNCATE_FLOAT_TO_INT(SSE_ADD_FLOATS(m_rpbin, m_pibin2));
                    if(need_rpavg && need_weightavg) union_mDperp.m_Dperp = SSE_MULTIPLY_FLOATS(union_mDperp.m_Dperp, union_mweight.m_weights);
                }
            #if  __INTEL_COMPILER
            #pragma unroll(SSE_NVEC)
            #endif
                for(int jj=0;jj<SSE_NVEC;jj++) {
                    const int ibin = union_finalbin.ibin[jj];
                    npairs[ibin]++;
                    if(need_rpavg) rpavg[ibin] += union_mDperp.Dperp[jj];
                    if(need_weightavg) weightavg[ibin] += union_mweight.weights[jj];
                }
            }
            }

            //Take care of the remainder
            for(;j<N1;j++) {

            if(need_costheta) pair.costheta.d = xhat1[j]*xhat0 + yhat1[j]*yhat0 + zhat1[j]*zhat0;

            const DOUBLE parx = xpos + *localx1;
            const DOUBLE pary = ypos + *localy1;
            const DOUBLE parz = zpos + *localz1;

            const DOUBLE perpx = *localx1++ - xpos;
            const DOUBLE perpy = *localy1++ - ypos;
            const DOUBLE perpz = *localz1++ - zpos;

            for(int w = 0; w < pair.num_weights; w++){
                pair.weights1[w].d = *local_w1.weights[w]++;
            }

            if(perpz >= max_dz) break;

            const DOUBLE sqr_s = perpx*perpx + perpy*perpy + perpz*perpz;
            if(sqr_s >= sqr_max_sep) continue;

            DOUBLE sqr_Dpar = ZERO, sqr_Dpar2 = ZERO;
            DOUBLE sqr_Dperp = ZERO, sqr_Dperp2 = ZERO;
            DOUBLE rp = ZERO, rp2 = ZERO;
            int pibin = npibin, pibin2 = npibin;
            if (sqr_s <= 0.) {
                pibin2 = pibin = (int) pimin_invstep;
            }
            else if (los_type == MIDPOINT_LOS) {
                const DOUBLE s_dot_l = parx*perpx + pary*perpy + parz*perpz;
                const DOUBLE sqr_l = parx*parx + pary*pary + parz*parz;
                const DOUBLE sqr_s_dot_l = s_dot_l * s_dot_l;
                if (sqr_s_dot_l >= sqr_l * sqr_pimax) continue;
                sqr_Dpar = sqr_s_dot_l / sqr_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                if(sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin) continue;
                const DOUBLE pi = SIGNED(SQRT(sqr_Dpar), s_dot_l);
                pibin = (int) (pi * inv_dpi + pimin_invstep);
                if (autocorr == 1) pibin2 = (int) (- pi * inv_dpi + pimin_invstep);
                if(need_rpavg || bin_type == BIN_LIN) rp = rp2 = SQRT(sqr_Dperp);
            }
            else {
                const DOUBLE s_dot_l = xhat0*perpx + yhat0*perpy + zhat0*perpz;
                sqr_Dpar = s_dot_l * s_dot_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                const int skip_pi = (sqr_Dpar >= sqr_pimax) || (sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin);
                if (autocorr == 1) {
                    const DOUBLE s_dot_l2 = xhat1[j]*perpx + yhat1[j]*perpy + zhat1[j]*perpz;
                    sqr_Dpar2 = s_dot_l2 * s_dot_l2;
                    sqr_Dperp2 = sqr_s - sqr_Dpar2;
                    const int skip_pi2 = (sqr_Dpar2 >= sqr_pimax) || (sqr_Dperp2 >= sqr_rpmax || sqr_Dperp2 < sqr_rpmin);
                    if (skip_pi && skip_pi2) continue;
                    if (skip_pi == 0) {
                        pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                    }
                    if (skip_pi2 == 0) {
                        pibin2 = (int) (- s_dot_l2 * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp2 = SQRT(sqr_Dperp2);
                    }
                }
                else {
                    if (skip_pi) continue;
                    pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                    if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                }
            }

            DOUBLE pairweight = ZERO;
            DOUBLE rpw = rp, rpw2 = rp2;

            if(need_weightavg){
                pair.dx.d = perpx;
                pair.dy.d = perpy;
                pair.dz.d = perpz;

                pair.parx.d = parx;
                pair.pary.d = pary;
                pair.parz.d = parz;

                pairweight = fallback_weight_func(&pair);
                if(need_rpavg) {
                   rpw = rp*pairweight;
                   if (autocorr == 1) rpw2 = rp2*pairweight;
                }
            }
            int kbin = 0;
            if (bin_type == BIN_LIN) kbin = (int) (rp*inv_rpstep + rpmin_invstep);
            else {
                for(kbin=nbin-1;kbin>=1;kbin--) {
                    if(sqr_Dperp >= rupp_sqr[kbin-1]) break;
                }//finding kbin
            }
            kbin *= npibin + 1;
            {
                const int ibin = kbin + pibin;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
            if (autocorr == 1) {
                if (los_type == FIRSTPOINT_LOS) {
                    if (bin_type == BIN_LIN) kbin = (int) (rp2*inv_rpstep + rpmin_invstep);
                    else {
                        for(kbin=nbin-1;kbin>=1;kbin--) {
                            if(sqr_Dperp2 >= rupp_sqr[kbin-1]) break;
                        }//finding kbin
                    }
                    kbin *= npibin + 1;
                }
                const int ibin = kbin + pibin2;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw2;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
        }//remainder jloop
    }//i-loop

    free(xhat1); free(yhat1); free(zhat1);

    return EXIT_SUCCESS;
}
#endif //SSE4.2 defined


static inline int countpairs_rp_pi_mocks_fallback_DOUBLE(const int64_t N0, DOUBLE *x0, DOUBLE *y0, DOUBLE *z0, const weight_struct_DOUBLE *weights0,
                                                         const int64_t N1, DOUBLE *x1, DOUBLE *y1, DOUBLE *z1, const weight_struct_DOUBLE *weights1,
                                                         const int same_cell,
                                                         const unsigned int fast_divide_and_NR_steps,
                                                         const DOUBLE rpmax, const DOUBLE rpmin, const int nbin,
                                                         const int npibin, const DOUBLE *rupp_sqr, const DOUBLE pimax,
                                                         const DOUBLE min_xdiff, const DOUBLE min_ydiff, const DOUBLE min_zdiff,
                                                         const DOUBLE closest_icell_xpos, const DOUBLE closest_icell_ypos,
                                                         const DOUBLE closest_icell_zpos,
                                                         DOUBLE *rpavg, uint64_t *npairs,
                                                         DOUBLE *weightavg, const weight_method_t weight_method, const pair_weight_struct pair_weight,
                                                         const bin_type_t bin_type, const los_type_t los_type, const int autocorr)
{
    if(N0 == 0 || N1 == 0) {
        return EXIT_SUCCESS;
    }

    if(npairs == NULL) {
        return EXIT_FAILURE;
    }

    const int32_t need_rpavg = rpavg != NULL;
    const int32_t need_weightavg = weightavg != NULL;
    int32_t need_costheta = need_weightavg;
    const DOUBLE sqr_rpmin=rpmin*rpmin, sqr_rpmax=rpmax*rpmax;
    DOUBLE inv_rpstep=0., rpmin_invstep=0.;
    if (bin_type == BIN_LIN) {
        inv_rpstep = (nbin - 1)/(rpmax - rpmin);
        rpmin_invstep = 1 - rpmin*inv_rpstep; //trick to avoid adding one to (r - rmin)/rstep
    }

    (void) fast_divide_and_NR_steps;//unused parameter but required to keep the same function signature amongst the kernels

    /*----------------- FALLBACK CODE --------------------*/
    const DOUBLE sqr_pimax = pimax*pimax;
    const DOUBLE sqr_max_sep = sqr_rpmax + sqr_pimax;
    const DOUBLE inv_dpi = ((DOUBLE) npibin)/(2*pimax);
    const DOUBLE pimin_invstep = pimax*inv_dpi;

    // A copy whose pointers we can advance
    weight_struct_DOUBLE local_w0 = {.weights={NULL}, .num_weights=0}, local_w1 = {.weights={NULL}, .num_weights=0};
    pair_struct_DOUBLE pair = {.num_weights=0};
    weight_func_t_DOUBLE weight_func = NULL;
    if(need_weightavg){
        // Same particle list, new copy of num_weights pointers into that list
        local_w0 = *weights0;
        local_w1 = *weights1;

        set_pair_struct_DOUBLE(&pair, &local_w0, &local_w1, &pair_weight);
        need_costheta = pair_weight.num;
        weight_func = get_weight_func_by_method_DOUBLE(weight_method);
    }
    DOUBLE *xhat1 = NULL, *yhat1 = NULL, *zhat1 = NULL;
    if (need_costheta || ((autocorr == 1) && (los_type == FIRSTPOINT_LOS))) {
        xhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        yhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        zhat1 = (DOUBLE *) my_malloc(N1, sizeof(DOUBLE));
        for(int64_t i=0;i<N1;i++) {
            const DOUBLE norm1 = SQRT(x1[i]*x1[i] + y1[i]*y1[i] + z1[i]*z1[i]);
            xhat1[i] = x1[i]/norm1;
            yhat1[i] = y1[i]/norm1;
            zhat1[i] = z1[i]/norm1;
        }
    }

    const DOUBLE *zstart = z1, *zend = z1 + N1;
    const DOUBLE max_all_dz = SQRT(sqr_max_sep - min_xdiff*min_xdiff - min_ydiff*min_ydiff);
    for(int64_t i=0;i<N0;i++) {
        const DOUBLE xpos = *x0++;
        const DOUBLE ypos = *y0++;
        const DOUBLE zpos = *z0++;
        for(int w = 0; w < pair.num_weights; w++){
            pair.weights0[w].d = *local_w0.weights[w]++;
        }
        DOUBLE xhat0 = ZERO, yhat0 = ZERO, zhat0 = ZERO;
        if (need_costheta || los_type == FIRSTPOINT_LOS) {
            const DOUBLE norm0 = SQRT(xpos*xpos + ypos*ypos + zpos*zpos);
            xhat0 = xpos/norm0;
            yhat0 = ypos/norm0;
            zhat0 = zpos/norm0;
        }

        DOUBLE max_dz = max_all_dz;

        /* Now consider if this i'th particle can be a valid pair with ANY of the remaining
           j' particles. The min. difference in the d-positions between this i'th particle and ANY
           of the remaining j'th particles, is the difference between the current j'th particle and
           the current i'th particle (since all remaining j'th particles will have a larger value for
           the z-ordinate and therefore a larger difference to zpos). if this `dsep` does not satisfy
           the distance criteria, then NO remaining j'th particles will. Continue on to the next i'th
           particle
        */
        const DOUBLE this_dz = *z1 - zpos;
        if(this_dz >= max_all_dz) {
            continue;
        }

        if(same_cell == 1) {
            z1++;
        } else {
            const DOUBLE min_dx = min_xdiff > 0 ? min_xdiff + FABS(xpos - closest_icell_xpos):min_xdiff;
            const DOUBLE min_dy = min_ydiff > 0 ? min_ydiff + FABS(ypos - closest_icell_ypos):min_ydiff;
            const DOUBLE min_dz = min_zdiff > 0 ? (this_dz > 0 ? this_dz:min_zdiff + FABS(zpos - closest_icell_zpos)):min_zdiff;
            const DOUBLE sqr_min_sep_this_point = min_dx*min_dx + min_dy*min_dy + min_dz*min_dz;
            if(sqr_min_sep_this_point >= sqr_max_sep) {
                continue;
            }
            max_dz = SQRT(sqr_max_sep - min_dx*min_dx - min_dy*min_dy);

            const DOUBLE target_z = zpos - max_all_dz;
            while(z1 != zend && *z1 <= target_z) {
                z1++;
            }
        }/* end of same_cell if condition*/

        /* are there any pairs possible with this particle and ANY
           of the j'th particles?
           Since both z0 and z1 are sorted in increasing order,
           the largest value for z1 is stored in last_z1. Therefore,
           the smallest difference between ANY of the remaining i'th particle
           and ANY of the j'th particle is:
           the current particle (i.e., the smallest remaining z-position among the 'i'-th dataset)
           and the last j'th particle. Therefore, if this difference is already too large
           to contain a valid pair, any remaining particle pairs CAN NOT be a valid pair

           --> we can safely terminate the i-loop (i.e., terminate the calculation for this pair of
           cells)
        */
        if(z1 == zend) {
            i = N0;
            break;
        }

        DOUBLE *localz1 = z1;
        const DOUBLE target_z = zpos - max_dz;
        while(localz1 != zend && *localz1 <= target_z) {
            localz1++;
        }

        const int64_t n_off = localz1 - zstart;
        const int64_t nleft = N1 - n_off;
        DOUBLE *localx1 = x1 + n_off;
        DOUBLE *localy1 = y1 + n_off;
        for(int w = 0; w < local_w1.num_weights; w++){
            local_w1.weights[w] = weights1->weights[w] + n_off;
        }

        int64_t localj = n_off - 1;

        for(int64_t j=0;j<nleft;j++){

            localj++;

            if(need_costheta) pair.costheta.d = xhat1[localj]*xhat0 + yhat1[localj]*yhat0 + zhat1[localj]*zhat0;

            const DOUBLE parx = xpos + *localx1;
            const DOUBLE pary = ypos + *localy1;
            const DOUBLE parz = zpos + *localz1;

            const DOUBLE perpx = *localx1++ - xpos;
            const DOUBLE perpy = *localy1++ - ypos;
            const DOUBLE perpz = *localz1++ - zpos;

            for (int w = 0; w < pair.num_weights; w++) pair.weights1[w].d = *local_w1.weights[w]++;

            /* particles are sorted on z, all future j particles will have larger value in localz1 -> perpz will be
               larger. therefore, if current perpz >= max_dz, all future iterations will also be larger. we can
               terminate the loop */
            if(perpz >= max_dz) break;

            const DOUBLE sqr_s = perpx*perpx + perpy*perpy + perpz*perpz;
            if(sqr_s >= sqr_max_sep) continue;

            DOUBLE sqr_Dpar = ZERO, sqr_Dpar2 = ZERO;
            DOUBLE sqr_Dperp = ZERO, sqr_Dperp2 = ZERO;
            DOUBLE rp = ZERO, rp2 = ZERO;
            int pibin = npibin, pibin2 = npibin;
            if (sqr_s <= 0.) {
                pibin2 = pibin = (int) pimin_invstep;
            }
            else if (los_type == MIDPOINT_LOS) {
                const DOUBLE s_dot_l = parx*perpx + pary*perpy + parz*perpz;
                const DOUBLE sqr_l = parx*parx + pary*pary + parz*parz;
                const DOUBLE sqr_s_dot_l = s_dot_l * s_dot_l;
                if (sqr_s_dot_l >= sqr_l * sqr_pimax) continue;
                sqr_Dpar = sqr_s_dot_l / sqr_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                if(sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin) continue;
                const DOUBLE pi = SIGNED(SQRT(sqr_Dpar), s_dot_l);
                pibin = (int) (pi * inv_dpi + pimin_invstep);
                if (autocorr == 1) pibin2 = (int) (- pi * inv_dpi + pimin_invstep);
                if(need_rpavg || bin_type == BIN_LIN) rp = rp2 = SQRT(sqr_Dperp);
            }
            else {
                const DOUBLE s_dot_l = xhat0*perpx + yhat0*perpy + zhat0*perpz;
                sqr_Dpar = s_dot_l * s_dot_l;
                sqr_Dperp = sqr_s - sqr_Dpar;
                const int skip_pi = (sqr_Dpar >= sqr_pimax) || (sqr_Dperp >= sqr_rpmax || sqr_Dperp < sqr_rpmin);
                if (autocorr == 1) {
                    const DOUBLE s_dot_l2 = xhat1[localj]*perpx + yhat1[localj]*perpy + zhat1[localj]*perpz;
                    sqr_Dpar2 = s_dot_l2 * s_dot_l2;
                    sqr_Dperp2 = sqr_s - sqr_Dpar2;
                    const int skip_pi2 = (sqr_Dpar2 >= sqr_pimax) || (sqr_Dperp2 >= sqr_rpmax || sqr_Dperp2 < sqr_rpmin);
                    if (skip_pi && skip_pi2) continue;
                    if (skip_pi == 0) {
                        pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                    }
                    if (skip_pi2 == 0) {
                        pibin2 = (int) (- s_dot_l2 * inv_dpi + pimin_invstep);
                        if(need_rpavg || bin_type == BIN_LIN) rp2 = SQRT(sqr_Dperp2);
                    }
                }
                else {
                    if (skip_pi) continue;
                    pibin = (int) (s_dot_l * inv_dpi + pimin_invstep);
                    if(need_rpavg || bin_type == BIN_LIN) rp = SQRT(sqr_Dperp);
                }
            }

            DOUBLE pairweight = ZERO;
            DOUBLE rpw = rp, rpw2 = rp2;

            if(need_weightavg){
                pair.dx.d = perpx;
                pair.dy.d = perpy;
                pair.dz.d = perpz;

                pair.parx.d = parx;
                pair.pary.d = pary;
                pair.parz.d = parz;

                pairweight = weight_func(&pair);
                if(need_rpavg) {
                   rpw = rp*pairweight;
                   if (autocorr == 1) rpw2 = rp2*pairweight;
                }
            }
            int kbin = 0;
            if (bin_type == BIN_LIN) kbin = (int) (rp*inv_rpstep + rpmin_invstep);
            else {
                for(kbin=nbin-1;kbin>=1;kbin--) {
                    if(sqr_Dperp >= rupp_sqr[kbin-1]) break;
                }//finding kbin
            }
            kbin *= npibin + 1;
            {
                const int ibin = kbin + pibin;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
            if (autocorr == 1) {
                if (los_type == FIRSTPOINT_LOS) {
                    if (bin_type == BIN_LIN) kbin = (int) (rp2*inv_rpstep + rpmin_invstep);
                    else {
                        for(kbin=nbin-1;kbin>=1;kbin--) {
                            if(sqr_Dperp2 >= rupp_sqr[kbin-1]) break;
                        }//finding kbin
                    }
                    kbin *= npibin + 1;
                }
                const int ibin = kbin + pibin2;
                npairs[ibin]++;
                if(need_rpavg) rpavg[ibin] += rpw2;
                if(need_weightavg) weightavg[ibin] += pairweight;
            }
        }//j loop over second set of particles
    }//i loop over first set of particles

    free(xhat1); free(yhat1); free(zhat1);

    return EXIT_SUCCESS;
}//end of fallback code
